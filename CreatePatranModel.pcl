/***********************************
 Needed Edits/Corrections:
  1) Add a check for displacement, both types (fixed/free and sclar value) cannont be present 
  2) Same thing for Loads only scalar or xyz
  3) load_Value_Value(VIRTUAL) does not seem to be necessary
  4) if Load Type == pressure, then Load_Value must be a scalar.  Should make this check
  5) Not a check for a solid pointing to a bogus material ID
  		Solid
			Count: 5
		   ID = 1
		   Element_Type = Tetra10
		   Material_ID = 10      // Bogus number, not handled properly
		   Mesh_Parameters_ID = 1
		   Name in Model = Solid 1 
 
  7) Get tolerance from Patran when checking if two points are equal (PatranModel.pointsAreEqual( in_Point, nearestPoint, .005 ))
  8) Must assure that all Solid::Element_Type = TETRA10 are the same type, cannot mix TETRA10 and TETRA4
  9) createSolidMesh is generic.  Need to support Tetra10 and 4, Mesh global parameters
  10) is there a check for file_Patran_Model_Name existing?

************************************/

#	Revision History
#	Date		Developer 	Revision
#	3/15/2016	R. Owens	Most of the Parsing completed
#				D. Yao		Added checkDataStructure functions
#	5/6/2016	R. Owens	Added Import parsolid model, identifying surfaces, loads, constraints, job submital 
#	5/12/2016   R. Owens	Patran_001_Youngs_to_Elastic  Changed Youngs_Modulus to Elastic_Modulus
#	5/12/2016	R. Owens	Patran_002_Load_Correction_Mesh_Params, corrected an error in retrieving load values. Add support for Mesh_Parameters when 
#							meshing the model.
#
#	*************************
#   How to Run This Program
#	*************************
#	This pcl file is submitted (i.e. run by Patran) via a command such as:
#		patran -b -graphics -sfp  Patran_Model.ses -stdout Patran_Model_pcl.log
#
#   ***********
#	Description
#	***********
#	The purpose of this pcl script is:
#		1. 	Create a Patran DB
#		2.	Import a Parasolid model, which could consist of solids and/or surfaces
#		3.	Create Materials
#		4.	Create Properties
#		5.  Assign properties to surfaces/solids  		// Note - Assigned to geometry not FEA elements
#		6.  Assign loads and constraints to surfaces  	// Note - Assigned to geometry not FEA elements
#		8.	Assign glue to dissimilar elements			// This is a future capability, not the first release
#		9.  Mesh the model with plates (CQUAD4 or 8) or solid (TETRA 4 or 10) elements, cannot mix plate and solid elements in same model
#		10.	Optionally, submit to solver			
#
#	Types of materials supported:
#		1. Isotropic
#		2. 3D Orthotropic
#
#	Composite Support
#		1. 2D Ply Stackups with 3D Orthotropic Material // CQUAD elements
#		
#	Composite Support in the Future (planned but not implemented)
#		1. Solid composite elements
#
#   **************
#	Pre-Conditions
#	**************
#	1. Patran 2014 must be installed on the machine running this program and a Patran license must be available
#
#	2. This program does no unit conversions.  It is the caller's responsibility
#	   to use a set of units (pressure (Elastic Modulus), density, force, dimensions)
#	   that will yield the desired output (e.g. stress, displacement) units.
#
#   ***************
#	Post-Conditions
#   ***************
#	Note - _SUCCEEDED.TXT is deleted at the beginning of the run if it exists.
#	1. If an error occurred, _FAILED.TXT will be created of it does not exist and appended to if it exists.  This file will be 
#	   in the directory from which this program was run.
#	2. If no errors occurred, 
#			_SUCCEEDED.TXT will be created.  This file will be in the directory from which this program was run.
#			A Patran model will be created and saved.
#	3. PatranModel_Application.log written.  This shows all the operations that were completed by this program.

#	******
#	Errors
#	******
#
#	****************************************
#	Supporting Information
#	****************************************#
#	This program creates a separate PSOLID card for each solid (Solid 1, Solid 2, Solid 3…) .  Solid 1 maps to 
#	PSOLID 1, Solid 2 to PSOLID 2, Solid 3 to PSOLID 3…  Since the post-processing program 
#	knows the mapping between PSOLIDs and component instance IDs, the stresses can be retrieve from the solver 
#	results data base based on PSOLID IDs and thus ultimately based on component instance IDs.   
#
#	For inseparable assemblies (e.g. parts welded together), it is the responsibility of the caller of this 
#	program to track that a group of solids that defines an inseparable assembly.  Then, in post-processing, the 
#	metrics(e.g. maximum stress, factor-of-safety...) of the group of parts should be returned.
#
#	*******************
# 	Composite 
#   *******************
#	Composites structures have characteristics similar to those of inseparable assemblies.  For a single composite structure, 
#   the surface model would actually be composed of surfaces that were split along boundaries that have different ply build-ups.  
#   Each of these split surfaces would have a separate PComp card.  It is the responsibility of the caller of this program to track 
#   the PComp cards belonging to a single component and return via post-processing the results for the entire component.    
#
# in_PatranInstall_Dir   e.g. "C:\MSC.Software\Patran_x64\20122"

# in_Working_Dir  e.g. 					"." 
#										"E:\Temp\scratch\2015_07_13_Patran_PCL_Code\Analysis\Mesher\Patran", both work
# in_ParasolidFile_DirAndFileName  e.g. "E:\Temp\scratch\2015_07_13_Patran_PCL_Code\Analysis\Mesher\Patran\support_plates_fea.x_t"
#										".\support_plates_fea.x_t"
#										"support_plates_fea.x_t"
#
#	###############################
#	Mesh Control Typical Parameters
#	###############################
#	Parameter							Type		Typical Value	Notes
#	------------------------------		----------	-------------	------------
#	meshMaxGlobalEdgeLength				Length		.1				Depends on the part size
#	meshMaxCurvDelta_Div_EdgeLen		Ratio		.1				Does NOT depend on part size
#	meshRatio_MinEdge_TO_MaxEdge		Ratio		.2				Does NOT depend on part size, typical value .2. This says the 
#																	minimum edge must be no less that 20% of the maximum edge			
#	meshMatchFaceProximityTol			Length		.005			Depends on the part size

#include “lpenums.p”

###############################################################################
FUNCTION 	formatErrorMessage( in_Error_Level, in_Function, in_Msg )
	STRING in_Error_Level[]
	STRING in_Function[]	
	STRING in_Msg[]
		
	STRING msg[1024]

	msg = in_Error_Level // ", Function: " //  in_Function // ", Message: " //in_Msg
	
	IF ( str_length(msg) > 256 ) THEN msg = str_substr(msg,1, 256) 

    return msg
END FUNCTION 
###############################################################################
FUNCTION addErrorMessage( in_Message, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
					
	STRING 	in_Message[]					
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()								
										
	if ( (in_out_ErrorMessages_current + 1) <= in_ErrorMessages_maxCount ) THEN 
		in_out_ErrorMessages_current += 1
		in_out_errorMessages(in_out_ErrorMessages_current) = in_Message
	END IF
											
END FUNCTION


CLASS PatranModel

						###############################
						# Constants for Error Messages
						###############################
	CLASSWIDE STRING 	c_ERROR[32],							@
						c_WARNING[32],							@
						c_INFORMATION[32]
						
						###############################################
						# Constants Defining Sections in the Input File
						###############################################
	CLASSWIDE STRING 	c_ANALYSIS[32], 						@
						c_FILES[32], 							@
						c_SUBCASE[32], 							@
						c_MESH_PARAMETERS[32], 					@
						c_MATERIAL[32], 						@
						c_SOLID[32],							@
						c_POINT[32],							@
						c_GEOMETRY[32],							@
						c_DISPLACEMENT[32],						@
						c_PIN[32],								@
						c_CONSTRAINT[32],						@
						c_LOAD_VALUE[32],                       @
						c_LOAD[32],								@
						c_MATERIAL_LAYUP[32],					@
						c_LAYER[32]
						
			
						###################################################################
						# Constants Defining Names for Named-Value Pairs in the Input File
						###################################################################
	CLASSWIDE STRING 	c_ID[32],								@
						c_DATE[32],								@	
						c_CONFIGURATION_ID[32],					@
						c_SOURCE_MODEL[32],						@
						c_TYPE[32],								@
						c_Element_Type[32],						@
						c_NAME[32],								@
						c_SOLVER[32],							@
						c_DESCRIPTION[32],						@
						c_CONSTRAINT_ID[32],					@
						c_LOAD_ID[32],							@
						c_INSTRUCTIONS[32],						@
						c_PATRAN_MODEL_NAME[32],				@									
						c_PATRAN_MODEL_DIR[32],					@
						c_GEOMETRY_FILE_NAME[32],				@
						c_GEOMETRY_FILE_DIR[32],				@
						c_GEOMETRY_FILE_TYPE[32],				@		
						c_MAX_GLOBAL_LENGTH[32],				@
						c_MAX_CURV_DELTA_DIV_EDGE_LEN[32],		@							
						c_RATIO_MIN_EDGE_TO_MAX_EDGE[32],		@
						c_MATCH_FACE_PROXIMITY_TOL[32],			@	
						c_MAT_TROPIC_TYPE[32],					@						
						c_ELASTIC_MODULUS[32],					@
						c_POISSONS_RATIO[32],					@
						c_DENSITY[32],							@
						c_THERM_EXPAN_COEF[32],					@							
						c_MATERIAL_ID[32],						@						
						c_MESH_PARAMETERS_ID[32],				@
						c_X_Cord[32],							@
						c_Y_Cord[32],							@
						c_Z_Cord[32],							@
						c_Point_ID[32],							@
						c_SubCase_ID[32],						@
						c_DISPLACEMENT_ID[32],					@
						c_PIN_ID[32],							@
						c_BALL_ID[32],							@
						c_GEOMETRY_ID[32],						@
						c_SCALAR_VALUE[32],						@
						c_VALUE[32],							@
						c_x_VALUE[32],							@
						c_y_VALUE[32],							@
						c_z_VALUE[32],							@
						c_LOAD_VALUE_ID[32],					@
						c_THICKNESS[32],						@
						c_ORIENTATION[32],						@
						c_DROP_ORDER[32]
												
						###################################
						# Constants Defining Value Contents
						###################################					
	CLASSWIDE STRING 	c_NASTRAN[32],							@
						c_MESH_AND_SOLVE[32],					@
						c_MESH_ONLY[32],						@		
						c_FACE[32],								@
						c_FIXED[32],							@
						c_FREE[32],								@
						c_CONSTRAINT_DISPLACEMENT[32],			@
						c_CONSTRAINT_PIN[32],					@	
						c_CONSTRAINT_BALL[32],					@					
						c_PRESSURE_type[32],					@
						c_PARASOLID[32],						@
						c_MAT_ISOTROPIC[32],					@
						c_MAT_ORTHOTROPIC[32],					@
						c_MAT_ANSITROPIC[32],					@	
						c_ELEMENT_TYPE_TETRA4[32],				@					
						c_ELEMENT_TYPE_TETRA10[32],				@
						c_ELEMENT_TYPE_CQUAD4[32],				@	
						c_ELEMENT_TYPE_CQUAD8[32],				@
						c_GEOMETRY_TYPE_FACE[32],				@
						c_x_Disp_State[32],						@  
						c_y_Disp_State[32],						@
						c_z_Disp_State[32],						@
						c_x_Rot_State[32],						@  
						c_y_Rot_State[32],						@
						c_z_Rot_State[32],						@					
						c_x_Disp_Val[32],						@
						c_y_Disp_Val[32],						@
						c_z_Disp_Val[32],						@
						c_x_Rot_Val[32],						@
						c_y_Rot_Val[32],						@
						c_z_Rot_Val[32],						@
						c_FORCE_type[32]						
						
	CLASSWIDE INTEGER	ci_NASTRAN,								@
						ci_MESH_AND_SOLVE,						@
						ci_MESH_ONLY,							@
						ci_PARASOLID,							@
						ci_MAT_ISOTROPIC,						@
						ci_MAT_ORTHOTROPIC,						@
						ci_MAT_ANSITROPIC,						@
						ci_ELEMENT_TYPE_TETRA4,					@					
						ci_ELEMENT_TYPE_TETRA10,				@
						ci_ELEMENT_TYPE_CQUAD4,					@	
						ci_ELEMENT_TYPE_CQUAD8,					@							
						ci_GEOMETRY_TYPE_FACE,					@
						ci_FIXED,								@
						ci_FREE,								@
						ci_CONSTRAINT_DISPLACEMENT,				@
						ci_CONSTRAINT_PIN,						@	
						ci_CONSTRAINT_BALL,						@
						ci_LOAD_PRESSURE,						@
						ci_LOAD_FORCE

						#########################################################
						# Constants Defined by Patran, Normally in include files
						#########################################################	
	CLASSWIDE INTEGER	ci_LP_SUBLIST_SURFACE,					@
						ci_LP_SUBLIST_SOLID,					@
						ci_LP_EVAL_FOR_ID,						@
						ci_LP_ATTRIBUTE_ID 

						
						########################################
						# Analysis (Should be only one of these)
						########################################	
						# ana_Count should always be one.  Capture the value for error checking
	CLASSWIDE INTEGER	ana_Count,			@
						ana_Count_temp
	CLASSWIDE INTEGER	ana_ID(VIRTUAL)
	CLASSWIDE STRING 	ana_Date[64](VIRTUAL), @
						ana_Configuration_ID[256](VIRTUAL)
						# ana_Type = 101, 103, 400
	CLASSWIDE STRING	ana_Source_Model[128](VIRTUAL)				
	CLASSWIDE INTEGER	ana_Type(VIRTUAL)
						# ana_Solver = ci_NASTRAN, No other solvers currently supported
	CLASSWIDE INTEGER 	ana_Solver(VIRTUAL)
						# ana_Instructions = ci_MESH_AND_SOLVE or ci_MESH_ONLY
	CLASSWIDE INTEGER	ana_Instructions(VIRTUAL)
						
						###########################
						# Files (Should be only one of these)
						###########################		
						# file_Count should always be one.  Capture the value for error checking
	CLASSWIDE INTEGER	file_Count,										@
						file_Count_temp
	CLASSWIDE STRING	file_Patran_Model_Name[256](VIRTUAL),			@
						file_Patran_Model_Dir[512](VIRTUAL),			@
						file_Geometry_File_Name[256](VIRTUAL),			@
						file_Geometry_File_Dir[512](VIRTUAL)
						# file_Geometry_File_Type = ci_PARSOLID, no other types supported
	CLASSWIDE INTEGER	file_Geometry_File_Type(VIRTUAL)	

						###########################################
						#  SubCase (Should be only one of these)
						###########################################		
						# SubCase should always be one.  Capture the value for error checking
	CLASSWIDE INTEGER	subcase_Count,									@
						subcase_Count_temp,								@
						subcase_ID(VIRTUAL),							@
						subcase_Constraint_ID(VIRTUAL),					@
						subcase_Load_ID(VIRTUAL)
	
						#################
						# Mesh_Parameters
						#################				
	CLASSWIDE INTEGER	mesh_Params_Count,							@
						mesh_Params_Count_temp,						@
						mesh_params_ID(VIRTUAL)
	CLASSWIDE REAL		mesh_Max_Global_Length(VIRTUAL),			@
						mesh_Max_Curv_Delta_Div_Edge_Ln(VIRTUAL),	@
						mesh_Ratio_Min_Edge_To_Max_Edge(VIRTUAL),	@
						mesh_Match_Face_Proximity_Tol(VIRTUAL)
						
						#################
						# Material
						#################	
	CLASSWIDE INTEGER	mat_Count,									@
						mat_Count_temp,								@
						mat_ID(VIRTUAL)
	CLASSWIDE STRING	mat_Name[128](VIRTUAL)		
	CLASSWIDE STRING	mat_InModelMaterialName[31](VIRTUAL)
	CLASSWIDE INTEGER	mat_Tropic_Type(VIRTUAL)
	CLASSWIDE STRING	mat_Description[245](VIRTUAL)
	CLASSWIDE REAL		mat_Elastic_Modulus(VIRTUAL),				@
						mat_Poissons_Ratio(VIRTUAL),				@
						mat_Density(VIRTUAL),						@
						mat_Therm_Expan_Coef(VIRTUAL)

						#################
						# Solid
						#################							
	CLASSWIDE INTEGER	sol_Count,									@
						sol_Count_temp,								@
						sol_ID(VIRTUAL),							@
						sol_Element_Type(VIRTUAL),					@
						sol_Mat_ID(VIRTUAL),						@
						sol_Mesh_Params_ID(VIRTUAL)				
	CLASSWIDE STRING	sol_InModelSolidName[31](VIRTUAL)										
									
						#################
						# Point
						#################							
	CLASSWIDE INTEGER	point_Count,								@
						point_Count_temp,							@
						point_ID(VIRTUAL)							
	CLASSWIDE REAL		point_x(VIRTUAL),							@
						point_y(VIRTUAL),							@
						point_z(VIRTUAL)

	CLASSWIDE LOGICAL	point_SurfaceInPatranModel(VIRTUAL)
	CLASSWIDE INTEGER	point_Mdl_SurfaceIDs_index(VIRTUAL)
	
						#################
						# Geometry
						#################							
	CLASSWIDE INTEGER	geometry_Count,								@
						geometry_Count_temp,						@
						geometry_ID(VIRTUAL),						@							
						geometry_Type(VIRTUAL),						@			
						geometry_Point_ID(VIRTUAL)
										
						#################
						# Displacement
						#################	
	CLASSWIDE INTEGER	disp_Count,									@
						disp_Count_temp,							@
						disp_ID(VIRTUAL)		
													
	CLASSWIDE INTEGER	x_Disp_State(VIRTUAL),						@  
						y_Disp_State(VIRTUAL),						@
						z_Disp_State(VIRTUAL),						@
						x_Rot_State(VIRTUAL),						@  
						y_Rot_State(VIRTUAL),						@
						z_Rot_State(VIRTUAL)
						
	CLASSWIDE LOGICAL	x_Disp_State_set(VIRTUAL),					@  
						y_Disp_State_set(VIRTUAL),					@
						z_Disp_State_set(VIRTUAL),					@
						x_Rot_State_set(VIRTUAL),					@  
						y_Rot_State_set(VIRTUAL),					@
						z_Rot_State_set(VIRTUAL)						
						
	# The displacement fields are mutually exclusive with the FIXED/FREE fields. One would exist but not the other
	CLASSWIDE REAL		x_Disp_Val(VIRTUAL),						@
						y_Disp_Val(VIRTUAL),						@
						z_Disp_Val(VIRTUAL),						@
						x_Rot_Val(VIRTUAL),							@
						y_Rot_Val(VIRTUAL),							@
						z_Rot_Val(VIRTUAL)
						
	CLASSWIDE LOGICAL	x_Disp_Val_set(VIRTUAL),					@
						y_Disp_Val_set(VIRTUAL),					@
						z_Disp_Val_set(VIRTUAL),					@
						x_Rot_Val_set(VIRTUAL),						@
						y_Rot_Val_set(VIRTUAL),						@
						z_Rot_Val_set(VIRTUAL)						

						#################
						# Pin,  Don't implement this yet, Not sure how this should work in Patran
						# In deck-based FEA, a start and end point is given and a point on the radius.
						# In Patran two surfaces (one for each half of the sphere) might be needed.
						#################	
	CLASSWIDE INTEGER	pin_Count,									@
						pin_Count_temp,								@
						pin_ID(VIRTUAL),							@
						pin_Axis_Start_Point_ID(VIRTUAL),			@
						pin_Axis_End_Point_ID(VIRTUAL)				
	CLASSWIDE STRING	pin_Axial_Rot_State[32](VIRTUAL),			@	
						pin_Axial_Disp_State[32](VIRTUAL)
						
						#################
						# Ball,  Don't implement this yet, Not sure how this should work in Patran
						# In deck-based FEA a center point and point on radius is used.  Maybe in Patran a 
						# surface (or maybe two surface representing the sphere would be needed.
						#################							
						
						#################
						# Constraint
						#################	
	CLASSWIDE INTEGER	constraint_Count,							@
						constraint_Count_temp,						@
						constraint_ID(VIRTUAL),						@	
						constraint_SubCase_ID(VIRTUAL)
						# Only Displacement supported, PIN and Ball Supported in future							
	CLASSWIDE INTEGER	constraint_Type(VIRTUAL),					@				
						constraint_Geometry_ID(VIRTUAL)
						# Only one of the following IDs (Displacement, Pin, or Ball) would exist depending on constraint_Type
	CLASSWIDE INTEGER	constraint_Displacement_ID(VIRTUAL),		@
						constraint_Pin_ID(VIRTUAL),					@
						constraint_Ball_ID(VIRTUAL)
	
						#################
						# Load_Value
						#################	
	CLASSWIDE INTEGER	load_Value_Count,							@
						load_Value_Count_temp,						@
						load_Value_ID(VIRTUAL)
	CLASSWIDE REAL		load_value_Scalar(VIRTUAL),					@
						load_Value_Value(VIRTUAL)					
	CLASSWIDE LOGICAL	load_Value_Scalar_Set(VIRTUAL),				@
						load_Value_Value_Set(VIRTUAL)
	CLASSWIDE REAL		load_Value_x(VIRTUAL),						@
						load_Value_y(VIRTUAL),						@
						load_Value_z(VIRTUAL)
	CLASSWIDE LOGICAL	load_Value_x_Set(VIRTUAL),					@
						load_Value_y_Set(VIRTUAL),					@
						load_Value_z_Set(VIRTUAL)
								
						#################
						# Load
						#################	
	CLASSWIDE INTEGER	load_Count,									@
						load_Count_temp,							@
						load_ID(VIRTUAL),							@
						load_SubCase_ID(VIRTUAL)					
	CLASSWIDE INTEGER	load_Type(VIRTUAL)	
	CLASSWIDE INTEGER	load_Geometry_ID(VIRTUAL),					@
						load_Load_Value_ID(VIRTUAL)					
								
						#################
						# Material Layup
						#################	
	CLASSWIDE INTEGER	material_layup_Count,						@
						material_layup_Count_temp,					@
						material_layup_ID(VIRTUAL),					@
						layer_Count,								@
						layer_Count_temp,							@
						layer_ID(VIRTUAL),							@
						layer_Material_ID(VIRTUAL),					@
						layer_Drop_Order(VIRTUAL)
	CLASSWIDE REAL		layer_Thickness(VIRTUAL),					@
						layer_Orientation(VIRTUAL)

						############################
						# Patran Model Geometry IDs
						############################				
	CLASSWIDE INTEGER	mdl_NumberSolids,							@
						mdl_SolidIDs(VIRTUAL),						@
						mdl_NumberSolidFaces(VIRTUAL)
						
	CLASSWIDE INTEGER	mdl_NumberSurfaces,							@
						mdl_SurfaceIDs_internal(VIRTUAL)
	CLASSWIDE STRING	mdl_SurfaceIDs_string[31](VIRTUAL)

						
###############################################################################				
FUNCTION  createModel( 	in_PatranInstall_Dir, 		@
						in_Working_Dir,				@
						in_FEAModelDefinitionFile,	@
						in_Log_DirAndFileName )

	STRING in_PatranInstall_Dir[]
	STRING in_Working_Dir[]
	STRING in_FEAModelDefinitionFile[]
	STRING in_Log_DirAndFileName[]		
	STRING  functionName[64] = "createModel"		
	
	STRING tempString[1024]
				
	INTEGER returnStatus = 0
	INTEGER errorMessages_maxCount = 100	
	INTEGER errorMessages_current = 0	
	STRING errorMessages[256](100)

	INTEGER logFile = 0	
	INTEGER i, j
	
	PatranModel.initializeConstants()	
	
	######################
	# Delete Old Files
	######################
	IF (file_exists("_SUCCEEDED.TXT","" )) THEN
		file_delete("_SUCCEEDED.TXT") 
	End IF


	IF (file_exists(in_Log_DirAndFileName,"" )) THEN
		file_delete(in_Log_DirAndFileName) 
	End IF
	
	
	IF (in_log_DirAndFileName != "") THEN
		# If the log file does not open properly, the messages will be written to the session log file (e.g. Patran_Model_Session.log)
		# patran -b -graphics -sfp  Patran_Model.ses -stdout Patran_Model_log.txt
		returnStatus = text_open( in_log_DirAndFileName, "NOW", 0, 0, logFile )		
		IF ( returnStatus != 0 ) THEN 
		     addErrorMessage( @
				formatErrorMessage( c_WARNING, functionName, "Could not open log file: " // in_log_DirAndFileName // ", Logging to session log file"), @
				errorMessages_maxCount, errorMessages_current, errorMessages) 
			# c_WARNING non fatal, set returnStatus = 0 
			returnStatus = 0  
		END IF
	END IF	
	
	text_write_string( logFile, "Date Time:       " // sys_date() // "  " // sys_time())
	text_write_string( logFile, "MSC Application: " // sys_product()// " " // sys_release())
	text_write_string ( logFile, "" )	
	text_write_string( logFile, "in_PatranInstall_Dir:      " // in_PatranInstall_Dir)
	text_write_string( logFile, "in_Working_Dir:            " // in_Working_Dir)
	text_write_string( logFile, "in_FEAModelDefinitionFile: " // in_FEAModelDefinitionFile)
	text_write_string( logFile, "in_Log_DirAndFileName:     " // in_Log_DirAndFileName)
	text_write_string( logFile, "" )			
	
	returnStatus = PatranModel.readFEAModelDefinition( in_Working_Dir, 			@
										in_FEAModelDefinitionFile,				@
										logFile, 								@
										errorMessages_maxCount,					@	
										errorMessages_current,					@									
										errorMessages )
			
			
	if ( returnStatus == 0 ) THEN	
		returnStatus = PatranModel.checkDataStructure( 	errorMessages_maxCount,			@	
														errorMessages_current,			@									
														errorMessages )
	END IF 			
			
	#####################################################
	# Set the the material name used in the Patran Model
	######################################################
	if ( returnStatus == 0 ) THEN		
		FOR ( i = 1 TO mat_Count )	
			mat_InModelMaterialName(i) = PatranModel.buildNameString ( "M", mat_ID(i), "_" // mat_Name(i), 31 )
		END FOR
	END IF 		
		
				
	#####################################################
	# Set the the solid name used in the Patran Model
	######################################################
	# Solid IDs (Solid 1, Solid 2,...) are in the order of the Parasolid file
	if ( returnStatus == 0 ) THEN	
		FOR ( i = 1 TO sol_Count )	
			sol_InModelSolidName(i) = "Solid " // str_from_integer(i)
		END FOR				
	END IF 				
	# Log Data
	
	if ( returnStatus == 0 ) THEN		
		PatranModel.logInMemoryFEAModelDefinition(logFile)	
	END IF 	
	
	####################
	# Create Patran DB	
	####################
	if ( returnStatus == 0 ) THEN   
	    # Delete the Patran DB if it exist.	
		tempString = file_Patran_Model_Dir(1) // "\" // file_Patran_Model_Name(1) // ".db"
		IF (file_exists(tempString, "" )) THEN
			file_delete(tempString) 
		End IF	
	
		returnStatus = PatranModel.createPatranDB (	file_Patran_Model_Name(1), 	@
										file_Patran_Model_Dir(1), 		@
										logFile, 						@
										errorMessages_maxCount,			@	
										errorMessages_current,			@									
										errorMessages )
	END IF
	
	################################
	# Set Patrans Working Directory	
	################################
	if ( returnStatus == 0 ) THEN   	
		returnStatus = PatranModel.setPatranWorkingDir ( file_Patran_Model_Dir(1), 		@
										logFile, 						@
										errorMessages_maxCount,			@	
										errorMessages_current,			@									
										errorMessages )			
	END IF	
	
	########################
	# Import Parasolid File	
	########################	
	if ( returnStatus == 0 ) THEN   
		#   Parasolid Models are always in meters
		#   in_Unit_Conversion_Factor = 1000, mm
		#   in_Unit_Conversion_Factor = 1, m
		#   in_Unit_Conversion_Factor = 39.370079, inch
		returnStatus = PatranModel.importParasolidFile (				@
										file_Geometry_File_Name(1), 	@
										file_Geometry_File_Dir(1), 		@
										1000.0,  						@  
										logFile, 						@
										errorMessages_maxCount,			@	
										errorMessages_current,			@									
										errorMessages )
																											
	END IF	
	
	########################
	# Materials
	########################	
	IF ( returnStatus == 0 ) THEN  
		FOR ( i = 1 TO mat_Count )
			IF ( mat_Tropic_Type(i) == ci_MAT_ISOTROPIC ) THEN
				returnStatus = PatranModel.createMaterials_MAT1(		@ 	
										mat_InModelMaterialName(i),		@	
										mat_Description(i),				@
										mat_Elastic_Modulus(i),			@
										mat_Poissons_Ratio(i),			@
										mat_Density(i),					@
										mat_Therm_Expan_Coef(i),		@
										logFile, 						@
										errorMessages_maxCount,			@	
										errorMessages_current,			@									
										errorMessages )		
				 IF ( returnStatus != 0 ) THEN BREAK  
			END IF
		END FOR
	END IF	
	
	########################
	# Property Sets
	########################	
	STRING  tempMaterialName[31]
	LOGICAL materialFound
	IF ( returnStatus == 0 ) THEN  
		materialFound = FALSE
		FOR ( i = 1 TO sol_Count )
			# Find material name			
			FOR ( j = 1 TO mat_Count )
				If ( sol_Mat_ID(i) == mat_ID(j)) THEN
					tempMaterialName = mat_InModelMaterialName(j)
					materialFound = TRUE
					BREAK
				END IF
			END FOR
				
			IF ( !materialFound ) THEN
				 addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Could not find material referenced by solid, solid ID: " // str_from_integer(sol_ID(i))), @
					errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1					
			END IF				

			#	Old approach mat_InModelMaterialName(sol_Mat_ID(i))
			IF ( returnStatus == 0 ) THEN
				returnStatus = PatranModel.createPropertySet_PSolid( 			@
										i, 										@
										tempMaterialName, 						@
										sol_InModelSolidName(i),				@
										logFile, 								@
										errorMessages_maxCount,					@	
										errorMessages_current,					@									
										errorMessages )		
				IF ( returnStatus != 0 ) THEN 
					BREAK  
				END IF  
			 END IF
		END FOR
	END IF		
	
	
	####################################################
	# Retrieve Patran Model Surface IDs and Face Counts
	####################################################	
	
	INTEGER mdl_SolidCount = 0
	
	IF ( returnStatus == 0 ) THEN  
		returnStatus = PatranModel.getModelSolidCount( 						@
									mdl_SolidCount, 						@								
									logFile, 								@
									errorMessages_maxCount,					@	
									errorMessages_current,					@									
									errorMessages )										

		IF ( returnStatus == 0 ) THEN 
			text_write_string ( logFile, "mdl_SolidCount: " // str_from_integer(mdl_SolidCount) )	
			mdl_NumberSolids = mdl_SolidCount
			sys_allocate_array ( mdl_SolidIDs, 			1, mdl_SolidCount )
			sys_allocate_array ( mdl_NumberSolidFaces, 	1, mdl_SolidCount )		

			returnStatus = PatranModel.getModelSolidIDsAndFaceIDs( 			@
										mdl_SolidCount,						@
										mdl_SolidIDs, 						@
										mdl_NumberSolidFaces,				@ 	
										logFile, 							@
										errorMessages_maxCount,				@	
										errorMessages_current,				@									
										errorMessages )	
					
			IF ( returnStatus == 0 ) THEN
				FOR ( i = 1 TO mdl_SolidCount BY 1 )			
					text_write_string( logFile, "Solid ID: " // str_from_integer(mdl_SolidIDs(i)) // "  Number of Faces: " // str_from_integer(mdl_NumberSolidFaces(i)))
				END FOR
			END IF
					
		End IF		
	END IF		
	
	####################################################
	# Set Surface IDs in this Program's Data Structures
	####################################################
	IF ( returnStatus == 0 ) THEN
		returnStatus = PatranModel.setSurfaceIDs( 			@
							mdl_SolidCount,					@
							mdl_SolidIDs, 					@
							mdl_NumberSolidFaces,			@
							mdl_NumberSurfaces, 	@
							mdl_SurfaceIDs_internal,		@
							mdl_SurfaceIDs_string,			@							
							logFile, 						@
							errorMessages_maxCount,			@	
							errorMessages_current,			@									
							errorMessages )		
	END IF
	
	###################
	# Log Surface IDs
	##################	
	IF ( returnStatus == 0 ) THEN
			PatranModel.logSurfaceIDs( mdl_NumberSurfaces, mdl_SurfaceIDs_internal, mdl_SurfaceIDs_string, logFile )		
	END IF	
	
	######################################
	# Set Mapping Surface IDs to Points 
	######################################	
	IF ( returnStatus == 0 ) THEN
		returnStatus =  PatranModel.setPoints_to_SurfaceInternalIDs(		@	
											point_Count, 					@
											point_x,						@
											point_y,						@
											point_z,						@
											mdl_NumberSurfaces,	@
											mdl_SurfaceIDs_internal, 		@
											point_SurfaceInPatranModel, 	@
											point_Mdl_SurfaceIDs_index, 	@
											logFile, 						@
											errorMessages_maxCount,			@	
											errorMessages_current,			@									
											errorMessages )				
	END IF
	
	
	######################################
	# Log Points to Surface IDs
	######################################	
	IF ( returnStatus == 0 ) THEN
		PatranModel.logPoints_to_SurfaceInternalIDs(					@	
									point_Count, 						@
									point_ID,							@
									point_x,							@
									point_y,							@
									point_z,							@
									point_SurfaceInPatranModel, 		@
									point_Mdl_SurfaceIDs_index, 		@
									mdl_SurfaceIDs_internal,			@
									mdl_SurfaceIDs_string,				@									
									logFile ) 	
	END IF
			
	########################################################################
	# Verify that Geometry Constructs Point to Surfaces in the Patran Model
	#######################################################################
	IF ( returnStatus == 0 ) THEN
		returnStatus = PatranModel.verify_Geometry_to_SurfaceIDs(	@
									geometry_Count,					@
									geometry_ID,					@
									geometry_Type,					@
									geometry_Point_ID,				@
									point_Count, 					@
									point_SurfaceInPatranModel, 	@
									logFile, 						@
									errorMessages_maxCount,			@	
									errorMessages_current,			@									
									errorMessages ) 				
	END IF
	
	########################################
	# Create Constraints in the Patran Model
	########################################	
	IF ( returnStatus == 0 ) THEN	
		STRING surfaceIDString_temp[31]
		LOGICAL indexFound
		INTEGER index
		FOR ( i = 1 to constraint_Count  )
			SWITCH ( constraint_Type(i))
				CASE(ci_CONSTRAINT_DISPLACEMENT )   		
					returnStatus = PatranModel.constraint_SurfaceIDString ( constraint_Geometry_ID(i), @
										  geometry_Count,								@
										  geometry_ID,									@
										  geometry_Point_ID,							@
										  point_Count,									@
										  point_ID,										@
										  point_Mdl_SurfaceIDs_index,					@
										  mdl_SurfaceIDs_string,						@
										  surfaceIDString_temp,							@
										  logFile, 										@
										  errorMessages_maxCount,						@	
										  errorMessages_current,						@									
										  errorMessages )
										  
						if ( returnStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "constraint_Geometry_ID(i) not found, Geometry_ID: "  @
								// str_from_integer(constraint_Geometry_ID(i))), @
								errorMessages_maxCount, errorMessages_current, errorMessages) 
							BREAK		
						END IF	
						
						text_write_string( 	logFile,"")
						text_write_string( 	logFile, "Processing constraint_ID(i): " // str_from_integer(constraint_ID(i)) //  @ 
											", constraint_Geometry_ID(i): " // str_from_integer(constraint_Geometry_ID(i)) //  @
											", Constrained to Surface: " // surfaceIDString_temp )
										  
						#########################
						# Find Displacement Index
						#########################	
						indexFound = FALSE
						FOR ( j = 1 TO disp_Count )
							If ( constraint_Displacement_ID(i) == disp_ID(j)) THEN
								index = j
								indexFound = TRUE
								BREAK
							END IF
						END FOR
						
						IF ( !indexFound ) THEN
							 addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not find displacement definition referenced by constraint, constraint ID: " // str_from_integer(constraint_ID(i))), @
								errorMessages_maxCount, errorMessages_current, errorMessages) 
								returnStatus = -1  
								BREAK
						END IF							
						
						if ( returnStatus == 0 ) THEN
							returnStatus = PatranModel.applyConstraint_Displacement(		@
												disp_ID(index),								@		
												surfaceIDString_temp, 						@							
												x_Disp_State(index),						@  
												y_Disp_State(index),						@
												z_Disp_State(index),						@
												x_Rot_State(index),							@  
												y_Rot_State(index),							@
												z_Rot_State(index),							@
																							@
												x_Disp_State_set(index),					@  
												y_Disp_State_set(index),					@
												z_Disp_State_set(index),					@
												x_Rot_State_set(index),						@  
												y_Rot_State_set(index),						@
												z_Rot_State_set(index),						@						
																							@
												x_Disp_Val(index),							@
												y_Disp_Val(index),							@
												z_Disp_Val(index),							@
												x_Rot_Val(index),							@
												y_Rot_Val(index),							@
												z_Rot_Val(index),							@
																							@
												x_Disp_Val_set(index),						@
												y_Disp_Val_set(index),						@
												z_Disp_Val_set(index),						@
												x_Rot_Val_set(index),						@
												y_Rot_Val_set(index),						@
												z_Rot_Val_set(index),						@							  
												logFile, 									@
												errorMessages_maxCount,						@	
												errorMessages_current,						@									
												errorMessages )								
						END IF
						
						if ( returnStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "applyConstraint_Displacement failed: " ), @
								errorMessages_maxCount, errorMessages_current, errorMessages) 		
						END IF					
				
				CASE(c_CONSTRAINT_PIN )
					addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Pin Constraint not supported" ), @
						errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1 									
				CASE(c_CONSTRAINT_BALL )
					addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Ball Constraint not supported" ), @
						errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1 							
					BREAK		
				DEFAULT
					addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Unknown constraint type encountered" ), @
						errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1 							
			END SWITCH	
		END FOR	
	END IF
	
	
	########################################
	# Create Loads in the Patran Model
	########################################	
	IF ( returnStatus == 0 ) THEN
		FOR ( i = 1 to load_Count  )
			SWITCH ( load_Type(i))
				CASE(ci_LOAD_PRESSURE )   		
					returnStatus = PatranModel.constraint_SurfaceIDString ( load_Geometry_ID(i), @
										  geometry_Count,								@
										  geometry_ID,									@
										  geometry_Point_ID,							@
										  point_Count,									@
										  point_ID,										@
										  point_Mdl_SurfaceIDs_index,					@
										  mdl_SurfaceIDs_string,						@
										  surfaceIDString_temp,							@
										  logFile, 										@
										  errorMessages_maxCount,						@	
										  errorMessages_current,						@									
										  errorMessages )
										  
						if ( returnStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "load_Geometry_ID(i) not found, Geometry_ID: "  @
								// str_from_integer(constraint_Geometry_ID(i))), @
								errorMessages_maxCount, errorMessages_current, errorMessages) 
							BREAK		
						END IF	
						
						text_write_string( 	logFile,"")
						text_write_string( 	logFile, "Processing load_ID(i): " // str_from_integer(load_ID(i)) //  @ 
											", load_Geometry_ID(i): " // str_from_integer(load_Geometry_ID(i)) //  @
											", Constrained to Surface: " // surfaceIDString_temp )
										  
				
						#########################
						# Find Load Index
						#########################	
						
						indexFound = FALSE
						FOR ( j = 1 TO load_Value_Count )
							If ( load_load_Value_ID(i) == load_Value_ID(j)) THEN
								index = j
								indexFound = TRUE
								BREAK
							END IF
						END FOR
						
						IF ( !indexFound ) THEN
							 addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not find displacement definition referenced by constraint, constraint ID: " // str_from_integer(constraint_ID(i))), @
								errorMessages_maxCount, errorMessages_current, errorMessages) 
								returnStatus = -1  
								BREAK
						END IF					
				
						if ( returnStatus == 0 ) THEN
							returnStatus = PatranModel.applyLoad_Pressure(	load_ID(i),					@
																		surfaceIDString_temp,			@	
																		load_value_Scalar(index),		@
																		load_Value_Scalar_Set(index),	@						
																		logFile, 						@
																		errorMessages_maxCount,			@	
																		errorMessages_current,			@									
																		errorMessages )						
						END IF						
									
						if ( returnStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "applyConstraint_Displacement failed: " ), @
								errorMessages_maxCount, errorMessages_current, errorMessages) 		
						END IF					
				
				CASE(ci_LOAD_FORCE )
					addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Force load not supported" ), @
						errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1 									

				DEFAULT
					addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Unknown force type encountered" ), @
						errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1 							
			END SWITCH	
		END FOR	
	END IF
	
	####################
	# Create Solid Mesh
	####################

	IF ( returnStatus == 0  && sol_Count > 0 ) THEN
		######################################################
		# There should be one and only one mesh_* parameters
		######################################################	
	
		IF ( mesh_Params_Count != 1 ) THEN
				addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, @
				"There must be one and only one set of Mesh_Parameters, Number Mesh_Parameters: " // str_from_integer( mesh_Params_Count)), @
				errorMessages_maxCount, errorMessages_current, errorMessages) 
					returnStatus = -1 
		END IF
		
		
		######################################################
		# The same sol_Element_Type must exists for all parts
		# Just use the first value  sol_Element_Type(1)
		######################################################	
		
		# There must be one and only one mesh_ parameters
		IF ( returnStatus == 0 ) THEN
			returnStatus = PatranModel.createSolidMesh( 			@
								sol_Element_Type(1),				@
								mesh_Max_Global_Length(1),			@
								mesh_Max_Curv_Delta_Div_Edge_Ln(1),	@
								mesh_Ratio_Min_Edge_To_Max_Edge(1),	@
								mesh_Match_Face_Proximity_Tol(1),	@
								logFile, 							@
								errorMessages_maxCount,				@	
								errorMessages_current,				@									
								errorMessages )	 	
		END IF
													
	END IF
	
	
	#############################
	# Export Graphis of the Mesh
	#############################	
	IF ( returnStatus == 0 ) THEN
		returnStatus = PatranModel.WriteMeshImagesAndVRML( 	logFile, 						@
															errorMessages_maxCount,			@	
															errorMessages_current,			@									
															errorMessages )	
	END IF
	
	#######################
	# Submit Job to Solver
	#######################	

	IF ( returnStatus == 0  && ana_Instructions(1) == ci_MESH_AND_SOLVE) THEN

		returnStatus = PatranModel.submitSolution101(	file_Patran_Model_Name(1),		@
														logFile, 						@
														errorMessages_maxCount,			@	
													    errorMessages_current,			@									
														errorMessages )			
														
	END IF
	
	WRITE ("errorMessages_maxCount: " // str_from_integer(errorMessages_maxCount) // ", errorMessages_current: " //  str_from_integer(errorMessages_current))
	

	IF ( returnStatus == 0  && errorMessages_current == 0 ) THEN
		INTEGER succeededFile = 0
		text_open( "_SUCCEEDED.TXT", "NOWA", 0, 0, succeededFile )	
		text_write_string ( succeededFile, "Processing completed successfully" )			
		text_write_string( succeededFile, "Date Time: " // sys_date() // "  " // sys_time())			
		text_write_string( succeededFile, "Patran model created/ran successfully.")
		text_close(succeededFile,"")		
		text_write_string ( logFile, "" )					
		text_write_string( logFile, "Patran model created/ran successfully, Date Time: " // sys_date() // "  " // sys_time())
		
	ELSE
		INTEGER failedFile = 0
		
		text_open( "_FAILED.TXT", "NOWA", 0, 0, failedFile )		
		FOR ( i = 1 TO errorMessages_current )
			text_write( failedFile, "%A%",returnStatus,0.0,errorMessages(i))
		END FOR
		text_close(failedFile,"")	
		
		text_write_string ( logFile, "" )		
		FOR ( i = 1 TO errorMessages_current )
			text_write( logFile, "%A%",returnStatus,0.0,errorMessages(i))
		END FOR

		text_write_string( logFile, "Patran model creation FAILED, Date Time: " // sys_date() // "  " // sys_time())
	END IF	

	
	text_close(logFile,"")	
	
	return returnStatus
	
END FUNCTION
###############################################################################
# Return -1 if not found
FUNCTION getIndexToID( in_Count, in_IDs, in_TargetId )

	INTEGER in_Count
	INTEGER in_IDs()
	INTEGER	in_TargetId

	INTEGER i
	
	FOR ( i = 1 To in_Count )
		IF ( in_IDs(i) == in_TargetId ) THEN
			RETURN i
		END IF
	END FOR
	
	RETURN -1

END FUNCTION
###############################################################################
FUNCTION constraint_SurfaceIDString ( in_Constraint_Geometry_ID,		@
									  in_Geometry_Count,				@
									  in_Geometry_ID,					@
									  in_Geometry_Point_ID,				@
									  in_Point_Count,					@
									  in_Point_ID,						@
									  in_Point_Mdl_SurfaceIDs_index,	@
									  in_Mdl_SurfaceIDs_string,			@
									  out_SurfaceIDString, 				@
									  in_logFile, 						@
									  in_ErrorMessages_maxCount,		@	
									  in_out_ErrorMessages_current,		@									
									  in_out_errorMessages )
									  			  
	INTEGER 	in_Constraint_Geometry_ID
	INTEGER		in_Geometry_Count
	INTEGER		in_Geometry_ID()
	INTEGER		in_Geometry_Point_ID()
	INTEGER		in_Point_Count
	INTEGER		in_Point_ID()	
	INTEGER 	in_Point_Mdl_SurfaceIDs_index()
	STRING 		in_Mdl_SurfaceIDs_string[]()
	STRING		out_SurfaceIDString[]
	
	INTEGER in_LogFile		
	REAL	in_Unit_Conversion_Factor
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()	

	STRING  functionName[64] = "constraint_SurfaceIDString"		
	
	out_SurfaceIDString = ""	
	
	INTEGER index
	
	index = PatranModel.getIndexToID( in_Geometry_Count, in_Geometry_ID, in_Constraint_Geometry_ID )
	
	if ( index == -1 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "Constraint_Geometry_ID not found, Geometry_ID: "  @
			// str_from_integer(in_Constraint_Geometry_ID)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
		RETURN -1	
	END IF	
	
	index = PatranModel.getIndexToID( in_Point_Count, in_Point_ID, in_Geometry_Point_ID(index) )	
	
	if ( index == -1 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "Point_ID not found, Point_ID: "  @
			// str_from_integer(in_Geometry_Point_ID(index))), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
		RETURN -1		
	END IF		
	
	out_SurfaceIDString = in_Mdl_SurfaceIDs_string(in_Point_Mdl_SurfaceIDs_index(index))
	
	RETURN 0
	
END FUNCTION
###############################################################################
FUNCTION initializeConstants()
	
	###############################
	# Constants for Error Messages
	###############################	
	c_ERROR = 						"ERROR"
	c_WARNING = 					"WARN"
	c_INFORMATION =					"INFO"
	
	###############################################
	# Constants Defining Sections in the Input File
	###############################################
	c_ANALYSIS = 					"Analysis"
	c_FILES = 						"Files"
	C_SUBCASE =						"SubCase"
	c_MESH_PARAMETERS = 			"Mesh_Parameters"
	c_MATERIAL = 					"Material"
	c_SOLID = 						"Solid"
	c_POINT = 						"Point"	
	c_GEOMETRY =					"Geometry"
	c_DISPLACEMENT =				"Displacement"
	c_PIN =							"Pin"
	c_CONSTRAINT =					"Constraint"
	c_LOAD_VALUE =					"Load_Value"
	c_LOAD =						"Load"	
	
	###################################################################
	# Constants Defining Names for Named-Value Pairs in the InputFile
	###################################################################
	c_ID = 							"ID"
	c_DATE = 						"Date"
	c_CONFIGURATION_ID	=			"Configuration_ID"
	c_SOURCE_MODEL = 				"Source_Model"
	c_TYPE = 						"Type"
	c_Element_Type =				"Element_Type"	
	c_NAME = 						"Name"
	c_SOLVER =						"Solver"
	c_DESCRIPTION = 				"Description"
	c_CONSTRAINT_ID =				"Constraint_ID"
	c_LOAD_ID =						"Load_ID"
	c_INSTRUCTIONS = 				"Instructions"
	c_PATRAN_MODEL_NAME = 			"Patran_Model_Name"
	c_PATRAN_MODEL_DIR = 			"Patran_Model_Dir"
	c_GEOMETRY_FILE_NAME = 			"Geometry_File_Name"
	c_GEOMETRY_FILE_DIR = 			"Geometry_File_Dir"
	c_GEOMETRY_FILE_TYPE = 			"Geometry_File_Type"
	c_MAX_GLOBAL_LENGTH = 			"Max_Global_Length"
	c_MAX_CURV_DELTA_DIV_EDGE_LEN = "Max_Curv_Delta_Div_Edge_Len"
	c_RATIO_MIN_EDGE_TO_MAX_EDGE = 	"Ratio_Min_Edge_To_Max_Edge"
	c_MATCH_FACE_PROXIMITY_TOL = 	"Match_Face_Proximity_Tol"
	c_MAT_TROPIC_TYPE =				"Tropic_Type"
	c_ELASTIC_MODULUS = 			"Elastic_Modulus"
	c_POISSONS_RATIO = 				"Poissons_Ratio"
	c_DENSITY = 					"Density"
	c_THERM_EXPAN_COEF = 			"Therm_Expan_Coef"
	c_MATERIAL_ID = 				"Material_ID"
	c_MESH_PARAMETERS_ID = 			"Mesh_Parameters_ID"
	c_X_Cord =						"x_Cord"
	c_Y_Cord =						"y_Cord"
	c_Z_Cord =						"z_Cord"
	c_Point_ID =					"Point_ID"
	c_SubCase_ID	= 				"SubCase_ID"
	c_DISPLACEMENT_ID =			    "Displacement_ID"
	c_PIN_ID =			    		"Pin_ID"	
	c_BALL_ID =			    		"Ball_ID"
	c_GEOMETRY_ID =					"Geometry_ID"
	c_SCALAR_VALUE =				"Scalar_Value"
	c_VALUE =						"Value"
	c_x_VALUE =						"x_Value"
	c_y_VALUE =						"y_Value"
	c_z_VALUE =						"z_Value"
	c_LOAD_VALUE_ID =				"Load_Value_ID"
	c_MATERIAL_LAYUP =				"Material_Layup"
	c_LAYER =						"Layer"
	c_THICKNESS =					"Thickness"
	c_ORIENTATION =					"Orientation"
	c_DROP_ORDER =					"Drop_Order"
	
	###################################
	# Constants Defining Value Contents
	###################################					
	c_NASTRAN = 					"NASTRAN"
	c_MESH_AND_SOLVE = 				"MESH_AND_SOLVE"
	c_MESH_ONLY = 					"MESH_ONLY"		
	c_FACE =						"FACE"
	c_FIXED =						"FIXED"
	c_FREE =						"FREE"
	c_CONSTRAINT_DISPLACEMENT =		"DISPLACEMENT"
	c_CONSTRAINT_PIN =				"PIN"	
	c_CONSTRAINT_BALL =				"BALL"		
	c_PRESSURE_type =				"PRESSURE"
	c_PARASOLID =					"Parasolid"
	c_MAT_ISOTROPIC =				"Isotropic"
	c_MAT_ORTHOTROPIC =				"Orthotropic"
	c_MAT_ANSITROPIC =				"Ansitropic "
	c_ELEMENT_TYPE_TETRA4 =			"Tetra4"					
	c_ELEMENT_TYPE_TETRA10 =		"Tetra10"
	c_ELEMENT_TYPE_CQUAD4 =			"CQuad4"	
	c_ELEMENT_TYPE_CQUAD8 =			"CQuad8"
	c_GEOMETRY_TYPE_FACE =			"FACE"
	c_x_Disp_State =				"x_Disp_State"  
	c_y_Disp_State =				"y_Disp_State"
	c_z_Disp_State =				"z_Disp_State"
	c_x_Rot_State =					"x_Rot_State"
	c_y_Rot_State =					"y_Rot_State"
	c_z_Rot_State =					"z_Rot_State"
	c_x_Disp_Val =					"x_Disp_Val"
	c_y_Disp_Val =					"y_Disp_Val"
	c_z_Disp_Val =					"z_Disp_Val"
	c_x_Rot_Val =					"x_Rot_Val"
	c_y_Rot_Val =					"y_Rot_Val"
	c_z_Rot_Val =					"z_Rot_Val"		
	c_FORCE_type =					"FORCE"
	
	
	
	ci_NASTRAN = 					1
	ci_MESH_AND_SOLVE =				1
	ci_MESH_ONLY =					2		
	ci_PARASOLID = 					1
	ci_MAT_ISOTROPIC =				1
	ci_MAT_ORTHOTROPIC = 			2
	ci_MAT_ANSITROPIC = 			3	
	ci_ELEMENT_TYPE_TETRA4	=		1						
	ci_ELEMENT_TYPE_TETRA10 = 		2
	ci_ELEMENT_TYPE_CQUAD4 = 		3	
	ci_ELEMENT_TYPE_CQUAD8 = 		4	
	ci_GEOMETRY_TYPE_FACE =			1
	ci_FIXED =						1
	ci_FREE	 =						2
	ci_CONSTRAINT_DISPLACEMENT = 	1
	ci_CONSTRAINT_PIN = 			2
	ci_CONSTRAINT_BALL = 			3
	ci_LOAD_PRESSURE =				1
	ci_LOAD_FORCE =					2	
	
	#############################
	# Patran Defined Constants
	#############################
	ci_LP_SUBLIST_SURFACE =			16		
	ci_LP_SUBLIST_SOLID = 			32	
	ci_LP_EVAL_FOR_ID =				4
	ci_LP_ATTRIBUTE_ID	=           1
			
	###################################
	# Initialize Array Counts to Zero
	###################################		
	ana_Count = 				0	
	ana_Count_temp = 			0	
	file_Count = 				0
	file_Count_temp = 			0
	subcase_Count = 			0
	subcase_Count_temp = 		0
	mesh_Params_Count = 		0
	mesh_Params_Count_temp = 	0	
	mat_Count = 				0
	mat_Count_temp = 			0	
	sol_Count = 				0
	sol_Count_temp = 			0
	point_Count = 				0
	point_Count_temp = 			0	
	geometry_Count = 			0
	geometry_Count_temp = 		0		
	disp_Count = 				0
	disp_Count_temp = 			0
	pin_Count = 				0
	pin_Count_temp = 			0	
	constraint_Count = 			0
	constraint_Count_temp = 	0	
	load_Value_Count =			0
	load_Value_Count_temp = 	0
	load_Count =				0
	load_Count_temp = 			0
	material_layup_Count =		0
	material_layup_Count_temp = 0
	layer_Count =				0
	layer_Count_temp =			0
	
	return 0
END FUNCTION
###############################################################################
FUNCTION solver_toStr ( in_Solver_ID )

	INTEGER in_Solver_ID
	
	IF ( in_Solver_ID == ci_NASTRAN ) THEN
		return c_NASTRAN
	ELSE
		return ""
	END IF

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION solver_toInt ( in_Solver_string )

	STRING in_Solver_string[]
	
	IF ( in_Solver_string == c_NASTRAN ) THEN
		return ci_NASTRAN
	ELSE
		return -1
	END IF
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION solver_validStrings()
	# if more are added, the strings would be separated by spaces
	return c_NASTRAN
	
END FUNCTION

##############################################################################
FUNCTION anaType_toStr ( in_anaType_ID )

	INTEGER in_anaType_ID
	
	IF ( in_anaType_ID == 101 ) THEN
		return "101"
	ELSE
		return ""
	END IF

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION anaType_toInt ( in_anaType_string )

	STRING in_anaType_string[]
	
	IF ( in_anaType_string == "101" ) THEN
		return 101
	ELSE
		return -1
	END IF
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION anaType_validStrings()
	# if more are added, the strings would be separated by spaces
	return "101"
	
END FUNCTION



##############################################################################
FUNCTION anaInstructions_toStr ( in_anaInstructions_ID )

	INTEGER in_anaInstructions_ID
	
	IF ( in_anaInstructions_ID == ci_MESH_AND_SOLVE ) THEN
		return c_MESH_AND_SOLVE
	ELSE IF ( in_anaInstructions_ID == ci_MESH_ONLY ) THEN
		return c_MESH_ONLY
	ELSE
		return ""
	END IF

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION anaInstructions_toInt ( in_anaInstructions_string )

	STRING in_anaInstructions_string[]
	
	IF ( in_anaInstructions_string == c_MESH_AND_SOLVE ) THEN
		return ci_MESH_AND_SOLVE
	ELSE IF ( in_anaInstructions_string == c_MESH_ONLY ) THEN
		return ci_MESH_ONLY
	ELSE
		return -1
	END IF
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION anaInstructions_validStrings()
	return c_MESH_AND_SOLVE // " " // c_MESH_ONLY
	
END FUNCTION

###############################################################################
FUNCTION ID_toStr ( in_ID_integer )

	INTEGER in_ID_integer
	INTEGER status
	
	IF ( in_ID_integer > 0 ) THEN
		return str_from_integer(in_ID_integer)
	ELSE
		return ""
	END IF

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION ID_toInt ( in_ID_string )

	STRING in_ID_string[]
	
	INTEGER status
	INTEGER results
	
	results = str_to_integer( in_ID_string, status)
	
	IF ( status == 0 ) THEN
		return results
	Else
		return -1
	END IF
	
END FUNCTION

###############################################################################

FUNCTION fileGeometry_File_Type_toStr ( in_fileGeometry_File_Type_ID )

	INTEGER in_fileGeometry_File_Type_ID

	IF ( in_fileGeometry_File_Type_ID == ci_PARASOLID ) THEN
		return c_PARASOLID
	ELSE
		return ""
	END IF

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION fileGeometry_File_Type_toInt ( in_fileGeometry_File_Type_str )

	STRING in_fileGeometry_File_Type_str[]
	
	IF ( in_fileGeometry_File_Type_str == c_PARASOLID ) THEN
		return ci_PARASOLID
	Else
		return -1
	END IF
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION fileGeometry_File_Type_vStrs()
	# if more are added, the strings would be separated by spaces
	return c_PARASOLID
	
END FUNCTION
##############################################################################
FUNCTION mat_Tropic_toStr ( in_mat_Tropic_ID )

	INTEGER in_mat_Tropic_ID

	SWITCH( in_mat_Tropic_ID )
		CASE( ci_MAT_ISOTROPIC )
			return c_MAT_ISOTROPIC
		CASE( ci_MAT_ORTHOTROPIC )	
			return c_MAT_ORTHOTROPIC
		CASE( ci_MAT_ANSITROPIC )		
			c_MAT_ANSITROPIC
		DEFAULT
			return ""
	END SWITCH

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION mat_Tropic_toInt ( in_mat_Tropic_str )

	STRING in_mat_Tropic_str[]
	
	SWITCH( in_mat_Tropic_str )
		CASE( c_MAT_ISOTROPIC )
			return ci_MAT_ISOTROPIC
		CASE( c_MAT_ORTHOTROPIC )	
			return ci_MAT_ORTHOTROPIC
		CASE( c_MAT_ANSITROPIC )		
			ci_MAT_ANSITROPIC
		DEFAULT
			return -1
	END SWITCH
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION mat_Tropic_validStrings()
	return c_MAT_ISOTROPIC// "  " // c_MAT_ORTHOTROPIC // "   " // c_MAT_ANSITROPIC
	
END FUNCTION
##############################################################################
FUNCTION sol_Element_Type_toStr ( in_sol_Element_Type_ID )

	INTEGER in_sol_Element_Type_ID

	SWITCH(in_sol_Element_Type_ID)
		CASE(ci_ELEMENT_TYPE_TETRA4)
			return c_ELEMENT_TYPE_TETRA4
		CASE( ci_ELEMENT_TYPE_TETRA10 )	
			return c_ELEMENT_TYPE_TETRA10
		CASE( ci_ELEMENT_TYPE_CQUAD4 )		
			c_ELEMENT_TYPE_CQUAD4
		CASE( ci_ELEMENT_TYPE_CQUAD8 )		
			c_ELEMENT_TYPE_CQUAD8			
		DEFAULT
			return ""
	END SWITCH

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION sol_Element_Type_toInt ( in_sol_Element_Type_str )

	STRING in_sol_Element_Type_str[]
	
	SWITCH(in_sol_Element_Type_str)
		CASE(c_ELEMENT_TYPE_TETRA4)
			return ci_ELEMENT_TYPE_TETRA4
		CASE( c_ELEMENT_TYPE_TETRA10 )	
			return ci_ELEMENT_TYPE_TETRA10
		CASE( c_ELEMENT_TYPE_CQUAD4 )		
			ci_ELEMENT_TYPE_CQUAD4
		CASE( c_ELEMENT_TYPE_CQUAD8 )		
			ci_ELEMENT_TYPE_CQUAD8	
		DEFAULT
			return -1
	END SWITCH
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION sol_Element_Type_validStrings()
	return c_ELEMENT_TYPE_TETRA4 // "  " // c_ELEMENT_TYPE_TETRA10 // "   " // c_ELEMENT_TYPE_CQUAD4 // "  " // c_ELEMENT_TYPE_CQUAD8	
	
END FUNCTION

##############################################################################
FUNCTION geometry_Type_toStr ( in_geometry_Type_ID )

	INTEGER in_geometry_Type_ID

	SWITCH(in_geometry_Type_ID)
		CASE(ci_GEOMETRY_TYPE_FACE)
			return c_GEOMETRY_TYPE_FACE
		DEFAULT
			return ""
	END SWITCH

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION geometry_Type_toInt ( in_geometry_Type_str )

	STRING in_geometry_Type_str[]
	
	SWITCH(in_geometry_Type_str)
		CASE(c_GEOMETRY_TYPE_FACE)
			return ci_GEOMETRY_TYPE_FACE
		DEFAULT
			return -1
	END SWITCH
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION geometry_Type_validStrings()
	# if more are added, the strings would be separated by spaces
	return c_GEOMETRY_TYPE_FACE	
END FUNCTION
##############################################################################
FUNCTION Fixed_Free_toStr ( in_Fixed_Free_ID )

	INTEGER in_Fixed_Free_ID

	SWITCH(in_Fixed_Free_ID)
		CASE(ci_FIXED )
			return c_FIXED
		CASE(ci_FREE )
			return c_FREE			
		DEFAULT
			return ""
	END SWITCH

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION Fixed_Free_toInt ( in_Fixed_Free_str )

	STRING in_Fixed_Free_str[]
	
	SWITCH(in_Fixed_Free_str)
		CASE(c_FIXED )
			return ci_FIXED
		CASE(c_FREE )
			return ci_FREE
		DEFAULT
			return -1
	END SWITCH
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION Fixed_Free_validStrings()
	# if more are added, the strings would be separated by spaces
	return c_FIXED // "  " // c_FREE	
END FUNCTION

##############################################################################
FUNCTION constraint_Type_toStr ( in_constraint_Type_ID )

	INTEGER in_constraint_Type_ID

	SWITCH(in_constraint_Type_ID)
		CASE(ci_CONSTRAINT_DISPLACEMENT )
			return c_CONSTRAINT_DISPLACEMENT
			
		# Pin and Ball not currently supported
		#CASE(ci_CONSTRAINT_PIN )
		#	return c_CONSTRAINT_PIN	
		#CASE(ci_CONSTRAINT_BALL )
		#	return c_CONSTRAINT_BALL					
		DEFAULT
			return ""
	END SWITCH

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION constraint_Type_toInt ( in_constraint_Type_str )

	STRING in_constraint_Type_str[]
	
	SWITCH(in_constraint_Type_str)
		CASE(c_CONSTRAINT_DISPLACEMENT )
			return ci_CONSTRAINT_DISPLACEMENT
		# Pin and Ball not currently supported			
		#CASE(c_CONSTRAINT_PIN )
		#	return ci_CONSTRAINT_PIN	
		#CASE(c_CONSTRAINT_BALL )
		#	return ci_CONSTRAINT_BALL	
		DEFAULT
			return -1
	END SWITCH
	
END FUNCTION
#------------------------------------------------------------------------------
FUNCTION constraint_Type_validStrings()
	# if more are added, the strings would be separated by spaces
	return c_FIXED // "  " // c_FREE	
END FUNCTION

##############################################################################
FUNCTION load_Type_toStr ( in_load_Type_ID )
	
	INTEGER in_load_Type_ID

	SWITCH(in_load_Type_ID)
		CASE(ci_LOAD_PRESSURE)
			return c_PRESSURE_type
		CASE (ci_LOAD_FORCE)
			return c_FORCE_type
		DEFAULT
			return -1
	END SWITCH

END FUNCTION
#------------------------------------------------------------------------------
FUNCTION load_Type_toInt ( in_load_Type_str )

	STRING in_load_Type_str[]
	
	SWITCH(in_load_Type_str)
		CASE(c_PRESSURE_type )
			return ci_LOAD_PRESSURE
		CASE(c_FORCE_type )
			return ci_LOAD_FORCE	

		DEFAULT
			return -1
	END SWITCH
	
END FUNCTION

###############################################################################
FUNCTION   readFEAModelDefinition (   	in_Working_Dir, 				@
										in_FEAModelDefinitionFile,		@
										in_logFile, 					@
										in_ErrorMessages_maxCount,		@	
										in_out_ErrorMessages_current,	@									
										in_out_errorMessages )										
										
	STRING 	in_Working_Dir[]
	STRING 	in_FEAModelDefinitionFile[]										
	INTEGER in_LogFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()	
	
	STRING  functionName[64] = "readFEAModelDefinition"	
	
	STRING 	fileName[1024] 
	INTEGER returnStatus = 0
	INTEGER modelFile
	STRING  buffer[2028]
	INTEGER length
	INTEGER lineNum
	LOGICAL shouldContinue
	
	INTEGER	loopIncrement
	INTEGER	maxInputFileLength = 1000
	
	LOGICAL unknownFieldFound 
	

	fileName = in_Working_Dir // "\" // in_FEAModelDefinitionFile
		
	text_write_string( in_LogFile, "Opening file: " // fileName)

    IF ( !file_exists(fileName,"") ) THEN		
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not find input file: " // fileName // ", Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN -1
    END IF	
	
    returnStatus = text_open( fileName, "OR", 0, 0, modelFile )

    IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not open input file: " // fileName // ", Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN -1		
		
        RETURN returnStatus
    END IF	
	
	lineNum = 0
	
	text_write_string( in_LogFile, "****************** Begin " // in_FEAModelDefinitionFile // " **********************")
    WHILE ( text_read_string( modelFile, buffer, length ) == 0 )
		lineNum += 1
		text_write_string( in_LogFile, buffer)
		
		shouldContinue = FALSE			
		buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum )
		# shouldContinue == TRUE means that the line was blank or contained only a comment
		If (shouldContinue ) THEN CONTINUE			
		
		IF ( buffer == c_ANALYSIS ) THEN 
			ana_Count += 1
		ELSE IF (buffer == c_FILES ) THEN
			file_Count += 1
		ELSE IF (buffer == c_SUBCASE ) THEN
			subcase_Count += 1			
		ELSE IF (buffer == c_MESH_PARAMETERS ) THEN
			mesh_Params_Count += 1
		ELSE IF (buffer == c_MATERIAL ) THEN	
			mat_Count += 1
		ELSE IF (buffer == c_SOLID ) THEN	
			sol_Count  += 1
		ELSE IF (buffer == c_POINT ) THEN	
			point_Count  += 1		
		ELSE IF (buffer == c_GEOMETRY ) THEN	
			geometry_Count  += 1						
		ELSE IF (buffer == c_DISPLACEMENT ) THEN	
			disp_Count  += 1						
		ELSE IF (buffer == c_PIN ) THEN	
			pin_Count  += 1	
		ELSE IF (buffer == c_CONSTRAINT ) THEN	
			constraint_Count += 1	
		ELSE IF (buffer == c_LOAD_VALUE ) THEN	
			load_Value_Count += 1	
		ELSE IF (buffer == c_LOAD ) THEN	
			load_Count += 1		
		ELSE IF (buffer == c_MATERIAL_LAYUP) THEN
			material_layup_Count += 1
		ELSE IF (buffer == c_LAYER) THEN
			layer_Count += 1
		ENDIF					
	END WHILE
	
	text_write_string( in_LogFile, "******************** End " // in_FEAModelDefinitionFile // " **********************")	
	
	##############################################################
	# Allocate arrays for fields that can contain multiple values
	##############################################################
	IF ( ana_Count > 0 ) THEN
		sys_allocate_array ( ana_ID, 			1, ana_Count )
		sys_allocate_array ( ana_Date, 			1, ana_Count )
		sys_allocate_array ( ana_Configuration_ID,1, ana_Count )		
		sys_allocate_array ( ana_Source_Model, 	1, ana_Count )		
		sys_allocate_array ( ana_Type, 			1, ana_Count )
		sys_allocate_array ( ana_Solver, 		1, ana_Count )
		sys_allocate_array ( ana_Instructions, 	1, ana_Count )			
	ENDIF
	
	IF ( file_Count > 0 ) THEN
		sys_allocate_array ( file_Patran_Model_Name, 		1, file_Count )
		sys_allocate_array ( file_Patran_Model_Dir, 		1, file_Count )
		sys_allocate_array ( file_Geometry_File_Name, 		1, file_Count )
		sys_allocate_array ( file_Geometry_File_Dir, 		1, file_Count )
		sys_allocate_array ( file_Geometry_File_Type, 		1, file_Count )		
	ENDIF	
	
	IF ( subcase_Count > 0 ) THEN
		sys_allocate_array ( subcase_ID, 					1, subcase_Count )
		sys_allocate_array ( subcase_Constraint_ID, 		1, subcase_Count )
		sys_allocate_array ( subcase_Load_ID, 				1, subcase_Count )		
	ENDIF		
	
		
	IF ( mesh_Params_Count > 0 ) THEN
		sys_allocate_array ( mesh_params_ID, 					1, mesh_Params_Count )
		sys_allocate_array ( mesh_Max_Global_Length, 			1, mesh_Params_Count )
		sys_allocate_array ( mesh_Max_Curv_Delta_Div_Edge_Ln, 	1, mesh_Params_Count )
		sys_allocate_array ( mesh_Ratio_Min_Edge_To_Max_Edge, 	1, mesh_Params_Count )
		sys_allocate_array ( mesh_Match_Face_Proximity_Tol, 	1, mesh_Params_Count )	
	ENDIF
	
	IF ( mat_Count > 0 ) THEN
		sys_allocate_array ( mat_ID, 				1,mat_Count )
		sys_allocate_array ( mat_Name, 				1,mat_Count )
		sys_allocate_array ( mat_InModelMaterialName, 		1,mat_Count )		
		sys_allocate_array ( mat_Tropic_Type, 		1,mat_Count )
		sys_allocate_array ( mat_Description, 		1,mat_Count )	
		sys_allocate_array ( mat_Elastic_Modulus, 	1,mat_Count )
		sys_allocate_array ( mat_Poissons_Ratio, 	1,mat_Count )
		sys_allocate_array ( mat_Density, 			1,mat_Count )
		sys_allocate_array ( mat_Therm_Expan_Coef, 	1,mat_Count )		
	ENDIF
	
	IF ( sol_Count > 0 ) THEN
		sys_allocate_array ( sol_ID, 				1, sol_Count )
		sys_allocate_array ( sol_Element_Type, 		1, sol_Count )
		sys_allocate_array ( sol_Mat_ID, 			1, sol_Count )
		sys_allocate_array ( sol_Mesh_Params_ID, 	1, sol_Count )		
		sys_allocate_array ( sol_InModelSolidName, 	1, sol_Count )			
	ENDIF
	
	IF ( point_Count > 0 ) THEN
		sys_allocate_array ( point_ID, 				1, point_Count )
		sys_allocate_array ( point_x, 				1, point_Count )
		sys_allocate_array ( point_y, 				1, point_Count )
		sys_allocate_array ( point_z, 				1, point_Count )	
		sys_allocate_array ( point_SurfaceInPatranModel,  	1,  point_Count )
		sys_allocate_array ( point_Mdl_SurfaceIDs_index, 1,  point_Count )
	ENDIF	
	
	IF ( geometry_Count > 0 ) THEN
		sys_allocate_array ( geometry_ID, 			1,  geometry_Count )
		sys_allocate_array ( geometry_Type, 		1,  geometry_Count )
		sys_allocate_array ( geometry_Point_ID,  	1,  geometry_Count )
		
	ENDIF	
	
	IF ( disp_Count > 0 ) THEN
		sys_allocate_array (disp_ID,   				1, 	disp_Count )									
		sys_allocate_array (x_Disp_State,   		1, 	disp_Count )
		sys_allocate_array (y_Disp_State,   		1, 	disp_Count )
		sys_allocate_array (z_Disp_State,   		1, 	disp_Count )
		sys_allocate_array (x_Rot_State,   			1, 	disp_Count ) 
		sys_allocate_array (y_Rot_State,   			1, 	disp_Count )
		sys_allocate_array (z_Rot_State,   			1, 	disp_Count )				
		sys_allocate_array (x_Disp_State_set,   	1, 	disp_Count )
		sys_allocate_array (y_Disp_State_set,   	1, 	disp_Count )
		sys_allocate_array (z_Disp_State_set,   	1, 	disp_Count )
		sys_allocate_array (x_Rot_State_set,   		1, 	disp_Count )  
		sys_allocate_array (y_Rot_State_set,   		1, 	disp_Count )
		sys_allocate_array (z_Rot_State_set,   		1, 	disp_Count )									
		sys_allocate_array (x_Disp_Val,   			1, 	disp_Count )
		sys_allocate_array (y_Disp_Val,   			1, 	disp_Count )
		sys_allocate_array (z_Disp_Val,   			1, 	disp_Count )
		sys_allocate_array (x_Rot_Val,   			1, 	disp_Count )
		sys_allocate_array (y_Rot_Val,   			1, 	disp_Count )
		sys_allocate_array (z_Rot_Val,   			1, 	disp_Count )	
		sys_allocate_array (x_Disp_Val_set,   		1, 	disp_Count )
		sys_allocate_array (y_Disp_Val_set,   		1, 	disp_Count )
		sys_allocate_array (z_Disp_Val_set,   		1, 	disp_Count )
		sys_allocate_array (x_Rot_Val_set,   		1, 	disp_Count )
		sys_allocate_array (y_Rot_Val_set,   		1, 	disp_Count )
		sys_allocate_array (z_Rot_Val_set,   		1, 	disp_Count )													
	ENDIF
	
	IF ( pin_Count > 0 ) THEN	
		sys_allocate_array (pin_ID,   					1, 	pin_Count )
		sys_allocate_array (pin_Axis_Start_Point_ID,   	1, 	pin_Count )
		sys_allocate_array (pin_Axis_End_Point_ID,   	1, 	pin_Count )
		sys_allocate_array (pin_Axial_Rot_State,   		1, 	pin_Count )		
		sys_allocate_array (pin_Axial_Disp_State,   	1, 	pin_Count )		
	ENDIF
	
	IF ( constraint_Count > 0 ) THEN	
		sys_allocate_array (constraint_ID,   			1, 	constraint_Count )		
		sys_allocate_array (constraint_SubCase_ID,   	1, 	constraint_Count )
		sys_allocate_array (constraint_Type,   			1, 	constraint_Count )
		sys_allocate_array (constraint_Geometry_ID,   	1, 	constraint_Count )
		sys_allocate_array (constraint_Displacement_ID,	1, 	constraint_Count )
		sys_allocate_array (constraint_Pin_ID,   		1, 	constraint_Count )
		sys_allocate_array (constraint_Ball_ID,   		1, 	constraint_Count )
	ENDIF
	
	IF ( load_Value_Count > 0 ) THEN
		sys_allocate_array (load_Value_ID,   			1, 	load_Value_Count )
		sys_allocate_array (load_value_Scalar,   		1, 	load_Value_Count )				
		sys_allocate_array (load_Value_Scalar_Set,   	1, 	load_Value_Count )	
		sys_allocate_array (load_Value_Value,   		1, 	load_Value_Count )				
		sys_allocate_array (load_Value_Value_Set,   	1, 	load_Value_Count )	
		sys_allocate_array (load_Value_x,   			1, 	load_Value_Count )	
		sys_allocate_array (load_Value_y,   			1, 	load_Value_Count )	
		sys_allocate_array (load_Value_z,   			1, 	load_Value_Count )	
		sys_allocate_array (load_Value_x_Set,   		1, 	load_Value_Count )	
		sys_allocate_array (load_Value_y_Set,   		1, 	load_Value_Count )	
		sys_allocate_array (load_Value_z_Set,   		1, 	load_Value_Count )	
	ENDIF	
	
	IF ( load_Count > 0 ) THEN
		sys_allocate_array (load_ID,   					1, 	load_Count )
		sys_allocate_array (load_SubCase_ID,   			1, 	load_Count )
		sys_allocate_array (load_Type,   				1, 	load_Count )
		sys_allocate_array (load_Geometry_ID,   		1, 	load_Count )
		sys_allocate_array (load_Load_Value_ID,   		1, 	load_Count )
	ENDIF	

	IF ( material_layup_Count > 0 ) THEN
		WRITE ("Allocated Material Layup Array!")
		sys_allocate_array (material_layup_ID,   		1, 	material_layup_Count,	1,	3 )
	ENDIF

	IF ( layer_Count > 0) THEN
		sys_allocate_array (layer_ID,					1,	layer_Count)			
		sys_allocate_array (layer_Material_ID,			1,	layer_Count)		
		sys_allocate_array (layer_Drop_Order,			1,	layer_Count)
		sys_allocate_array (layer_Thickness,			1,	layer_Count)
		sys_allocate_array (layer_Orientation,			1,	layer_Count)
	ENDIF

	######################################################
	# Initialize Variables 
	# This must be after the calls to sys_allocate_array
	######################################################	
	PatranModel.initializeVariables()	
	
	############################
	# Read the name/value pairs
	############################	
	# Set to the beginning the model file
	
	returnStatus = text_set_position(modelFile, 0 )
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not reset input file to the starting position, File: " // fileName // ", Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
		return returnStatus
	END IF

	lineNum = 0
	
	loopIncrement = 0
	
    WHILE ( text_read_string( modelFile, buffer, length ) == 0 )
	
		lineNum += 1
		shouldContinue = FALSE			
		buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum )
		# shouldContinue == TRUE means that the line was blank or contained only a comment
		If (shouldContinue ) THEN CONTINUE
		
		WRITE ( "***MAIN After**** " // str_from_integer(lineNum) // "  " // buffer )

		unknownFieldFound = FALSE
		# use loopIncrement to protect from a runaway program 
		WHILE ( !unknownFieldFound &&  loopIncrement < maxInputFileLength && buffer != "" )
			loopIncrement += 1
			SWITCH ( buffer )
			   CASE( c_ANALYSIS )  
					PatranModel.readAnalysis_NameValPairs(  @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
					WRITE( " MAIN Buffer: " // buffer // ", String Length: " // str_from_integer(str_length(buffer) ) )
			   CASE(  c_FILES ) 
					PatranModel.readFiles_NameValuePairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_SUBCASE )   
					PatranModel.readSubCase_NameValuePairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)			
			   CASE(  c_MESH_PARAMETERS ) 
					PatranModel.readMeshParameters_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_MATERIAL ) 	
					PatranModel.readMaterial_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)	
			   CASE(  c_SOLID ) 	
					PatranModel.readSolid_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_POINT ) 	
					PatranModel.readPoint_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_GEOMETRY ) 	
					PatranModel.readGeometry_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)			
			   CASE(  c_DISPLACEMENT ) 	
					PatranModel.readDisplacement_NameValPairs(  @ 
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_PIN ) 	
					PatranModel.readPin_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_CONSTRAINT ) 	
					PatranModel.readConstraint_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_LOAD_VALUE ) 	
					PatranModel.readLoadValue_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_LOAD )
					PatranModel.readLoad_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   CASE(  c_MATERIAL_LAYUP )
					PatranModel.readMaterialLayup_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, lineNum, buffer)
			   DEFAULT
					addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Unexpected string encountered, Line number: " // str_from_integer(lineNum) //  ", String: " // buffer ), @
						in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
					unknownFieldFound = TRUE
			END SWITCH				
		END WHILE
		
	END WHILE
	
	text_close(modelFile,"")	
	
	IF ( ( loopIncrement  ) >= maxInputFileLength ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "Exceeded maximum number of lines in input file, Line count: " // str_from_integer(loopIncrement) ), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages)	
	END IF 

		

	
	IF ( in_out_ErrorMessages_current > 0 ) THEN
		return -1
	Else
		return 0
	END IF
		
END FUNCTION				
###############################################################################
FUNCTION logInMemoryFEAModelDefinition(in_logFile)
	# The data read and logged by this function is all contained as
	# class variables
	INTEGER in_LogFile		
	Integer i
	
	text_write_string( in_LogFile, "******************** Begin In-Memory FEA Model Definition **********************")		
	
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_ANALYSIS)  
	text_write_string( in_LogFile, "   Count: " // str_from_integer(ana_Count_temp))
	FOR ( i = 1 TO ana_Count )
		text_write_string( in_LogFile, "")
		text_write_string( in_LogFile, "   " // c_ID 					// " = " // PatranModel.ID_toStr (ana_ID(i)) )
		text_write_string( in_LogFile, "   " // c_DATE 					// " = " // ana_Date(i) )	
		text_write_string( in_LogFile, "   " // c_CONFIGURATION_ID 		// " = " // ana_Configuration_ID(i) )
		text_write_string( in_LogFile, "   " // c_SOURCE_MODEL 			// " = " // ana_Source_Model(i) )	
		text_write_string( in_LogFile, "   " // c_TYPE 					// " = " // PatranModel.anaType_toStr(ana_Type(i)) )
		text_write_string( in_LogFile, "   " // c_SOLVER 				// " = " // PatranModel.solver_toStr (ana_Solver(i)) )
		text_write_string( in_LogFile, "   " // c_INSTRUCTIONS 			// " = " // PatranModel.anaInstructions_toStr(ana_Instructions(i)) )	
	END FOR

	
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_FILES)  	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(file_Count_temp))
	FOR ( i = 1 TO file_Count_temp )
		text_write_string( in_LogFile, "")
		text_write_string( in_LogFile, "   " // c_PATRAN_MODEL_NAME 	// " = " // file_Patran_Model_Name(i) )
		text_write_string( in_LogFile, "   " // c_PATRAN_MODEL_DIR 		// " = " // file_Patran_Model_Dir(i) )	
		text_write_string( in_LogFile, "   " // c_GEOMETRY_FILE_NAME 	// " = " // file_Geometry_File_Name(i) )
		text_write_string( in_LogFile, "   " // c_GEOMETRY_FILE_DIR 	// " = " // file_Geometry_File_Dir(i) )	
		text_write_string( in_LogFile, "   " // c_GEOMETRY_FILE_TYPE 	// " = " // PatranModel.fileGeometry_File_Type_toStr(file_Geometry_File_Type(i)) )
	END FOR
	
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_SUBCASE) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(subcase_Count_temp))	
	FOR ( i = 1 TO subcase_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 				// " = " // PatranModel.ID_toStr (subcase_ID(i)) )
			text_write_string( in_LogFile, "   " // c_CONSTRAINT_ID 	// " = " // PatranModel.ID_toStr (subcase_Constraint_ID(i)) )
			text_write_string( in_LogFile, "   " // c_LOAD_ID 			// " = " // PatranModel.ID_toStr (subcase_Load_ID(i)) )			
	END FOR
		
		
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_MESH_PARAMETERS) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(mesh_params_Count_temp))	
	FOR ( i = 1 TO mesh_params_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 							// " = " // PatranModel.ID_toStr (mesh_params_ID(i)) )
			
			text_write_string( in_LogFile, "   " // c_MAX_GLOBAL_LENGTH				// " = " // str_from_real(mesh_Max_Global_Length(i) ))
			text_write_string( in_LogFile, "   " // c_MAX_CURV_DELTA_DIV_EDGE_LEN	// " = " // str_from_real(mesh_Max_Curv_Delta_Div_Edge_Ln(i) ))
			text_write_string( in_LogFile, "   " // c_RATIO_MIN_EDGE_TO_MAX_EDGE	// " = " // str_from_real(mesh_Ratio_Min_Edge_To_Max_Edge(i) ))
			text_write_string( in_LogFile, "   " // c_MATCH_FACE_PROXIMITY_TOL		// " = " // str_from_real(mesh_Match_Face_Proximity_Tol(i) ))
	END FOR		
		
		
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_MATERIAL) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(mat_Count_temp))	
	FOR ( i = 1 TO mat_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 				// " = " // PatranModel.ID_toStr (mat_ID(i)) )
			text_write_string( in_LogFile, "   " // c_NAME 				// " = " // mat_Name(i) )
			text_write_string( in_LogFile, "   " // "Name in Model" 	// " = " // mat_InModelMaterialName(i) )			
			text_write_string( in_LogFile, "   " // c_MAT_TROPIC_TYPE 	// " = " // PatranModel.mat_Tropic_toStr(mat_Tropic_Type(i)) )	
			text_write_string( in_LogFile, "   " // c_DESCRIPTION		// " = " // mat_Description(i) )
			
			text_write_string( in_LogFile, "   " // c_ELASTIC_MODULUS	// " = " // str_from_real(mat_Elastic_Modulus(i) ))
			text_write_string( in_LogFile, "   " // c_POISSONS_RATIO	// " = " // str_from_real(mat_Poissons_Ratio(i) ))
			text_write_string( in_LogFile, "   " // c_DENSITY			// " = " // str_from_real(mat_Density(i) ))
			text_write_string( in_LogFile, "   " // c_THERM_EXPAN_COEF	// " = " // str_from_real(mat_Therm_Expan_Coef(i) ))
	END FOR		
	
	text_write_string( in_LogFile, "******************** END In-Memory FEA Model Definition **********************")		
		
		
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_SOLID) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(sol_Count_temp))	
	FOR ( i = 1 TO sol_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 					// " = " // PatranModel.ID_toStr(sol_ID(i)) )
			text_write_string( in_LogFile, "   " // c_Element_Type 			// " = " // PatranModel.sol_Element_Type_toStr (sol_Element_Type(i)) )
			text_write_string( in_LogFile, "   " // c_MATERIAL_ID 			// " = " // PatranModel.ID_toStr(sol_Mat_ID(i)) )
			text_write_string( in_LogFile, "   " // c_MESH_PARAMETERS_ID 	// " = " // PatranModel.ID_toStr(sol_Mesh_Params_ID(i)) )
			text_write_string( in_LogFile, "   " // "Name in Model" 	    // " = " // sol_InModelSolidName(i) )
	END FOR

	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_POINT) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(point_Count_temp))	
	FOR ( i = 1 TO point_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 		// " = " // PatranModel.ID_toStr(point_ID(i)) )
			text_write_string( in_LogFile, "   " // c_X_Cord 	// " = " // str_from_real(point_x(i)) )
			text_write_string( in_LogFile, "   " // c_Y_Cord 	// " = " //	str_from_real(point_y(i)) )
			text_write_string( in_LogFile, "   " // c_Z_Cord 	// " = " // str_from_real(point_z(i)) )			
	END FOR	
	
	
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_GEOMETRY) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(geometry_Count_temp))	
	FOR ( i = 1 TO geometry_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 					// " = " // PatranModel.ID_toStr(geometry_ID(i)) )
			text_write_string( in_LogFile, "   " // c_Type 					// " = " // PatranModel.geometry_Type_toStr (geometry_Type(i)) )
			text_write_string( in_LogFile, "   " // c_Point_ID				// " = " // PatranModel.ID_toStr(geometry_Point_ID(i)) )				
	END FOR	
	
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_DISPLACEMENT) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(disp_Count_temp))	
	FOR ( i = 1 TO disp_Count_temp )
			text_write_string( in_LogFile, "")	
			text_write_string( in_LogFile, "   " // c_ID 					// " = " // PatranModel.ID_toStr(disp_ID(i)) )
			
			text_write_string( in_LogFile, "   " // c_x_Disp_State 					// " = " // PatranModel.Fixed_Free_toStr (x_Disp_State(i)) )
			text_write_string( in_LogFile, "   " // c_y_Disp_State 					// " = " // PatranModel.Fixed_Free_toStr (y_Disp_State(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Disp_State 					// " = " // PatranModel.Fixed_Free_toStr (z_Disp_State(i)) )

			text_write_string( in_LogFile, "   " // c_x_Rot_State 					// " = " // PatranModel.Fixed_Free_toStr (x_Rot_State(i)) )
			text_write_string( in_LogFile, "   " // c_y_Rot_State 					// " = " // PatranModel.Fixed_Free_toStr (y_Rot_State(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Rot_State 					// " = " // PatranModel.Fixed_Free_toStr (z_Rot_State(i)) )		
	
			text_write_string(in_LogFile,"" )
			
			text_write_string( in_LogFile, "   " // c_x_Disp_State 				// "_set = " // str_from_logical (x_Disp_State_set(i)) )
			text_write_string( in_LogFile, "   " // c_y_Disp_State 				// "_set = " // str_from_logical (y_Disp_State_set(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Disp_State 				// "_set = " // str_from_logical (z_Disp_State_set(i)) )
			
			text_write_string( in_LogFile, "   " // c_x_Rot_State 				// "_set = " // str_from_logical (x_Rot_State_set(i)) )
			text_write_string( in_LogFile, "   " // c_y_Rot_State 				// "_set = " // str_from_logical (y_Rot_State_set(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Rot_State 				// "_set = " // str_from_logical (z_Rot_State_set(i)) )				
			
			text_write_string(in_LogFile,"" )		
			
			text_write_string( in_LogFile, "   " // c_x_Disp_Val 					// " = " // str_from_real (x_Disp_Val(i)) )
			text_write_string( in_LogFile, "   " // c_y_Disp_Val 					// " = " // str_from_real (y_Disp_Val(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Disp_Val 					// " = " // str_from_real(z_Disp_Val(i)) )

			text_write_string( in_LogFile, "   " // c_x_Rot_Val 					// " = " // str_from_real (x_Rot_Val(i)) )
			text_write_string( in_LogFile, "   " // c_y_Rot_Val 					// " = " // str_from_real (y_Rot_Val(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Rot_Val 					// " = " // str_from_real (z_Rot_Val(i)) )		
	
			text_write_string(in_LogFile,"" )
			
			text_write_string( in_LogFile, "   " // c_x_Disp_Val 				// "_set = " // str_from_logical (x_Disp_Val_set(i)) )
			text_write_string( in_LogFile, "   " // c_y_Disp_Val 				// "_set = " // str_from_logical (y_Disp_Val_set(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Disp_Val 				// "_set = " // str_from_logical (z_Disp_Val_set(i)) )
			
			text_write_string( in_LogFile, "   " // c_x_Rot_Val 				// "_set = " // str_from_logical (x_Rot_Val_set(i)) )
			text_write_string( in_LogFile, "   " // c_y_Rot_Val 				// "_set = " // str_from_logical (y_Rot_Val_set(i)) )			
			text_write_string( in_LogFile, "   " // c_z_Rot_Val 				// "_set = " // str_from_logical (z_Rot_Val_set(i)) )				
			
			
	END FOR		

	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_CONSTRAINT) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(constraint_Count_temp))	
	FOR (i = 1 TO constraint_Count_temp)
			text_write_string( in_LogFile, "" )	
			text_write_string( in_LogFile, "   " // c_ID 							// " = " // PatranModel.ID_toStr(constraint_ID(i)) )
			text_write_string( in_LogFile, "   " //	c_Type							// " = " // PatranModel.constraint_Type_toStr(constraint_Type(i)) )
			text_write_string( in_LogFile, "   " // c_SUBCASE_ID					// " = " // PatranModel.ID_toStr(constraint_SubCase_ID(i)) )
			text_write_string( in_LogFile, "   " // c_GEOMETRY_ID					// " = " // PatranModel.ID_toStr(constraint_Geometry_ID(i)) )
			text_write_string( in_LogFile, "   " // c_DISPLACEMENT_ID				// " = " // PatranModel.ID_toStr(constraint_Displacement_ID(i)) )
			text_write_string( in_LogFile, "   " // c_PIN_ID						// " = " // PatranModel.ID_toStr(constraint_Pin_ID(i)) )
			text_write_string( in_LogFile, "   " // c_BALL_ID						// " = " // PatranModel.ID_toStr(constraint_Ball_ID(i)) )
	END FOR

	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_LOAD_VALUE) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(load_value_Count_temp))	
	FOR (i = 1 TO load_value_Count_temp)
			text_write_string( in_LogFile, "" )	
			text_write_string( in_LogFile, "   " // c_ID 							// " = " // PatranModel.ID_toStr(load_Value_ID(i)) )
			text_write_string( in_LogFile, "   " // c_VALUE 						// " = " // str_from_real(load_Value_Value(i)) )
			text_write_string( in_LogFile, "   " // c_SCALAR_VALUE 					// " = " // str_from_real(load_value_Scalar(i)) )
			text_write_string( in_LogFile, "   " // c_x_VALUE 						// " = " // str_from_real(load_Value_x(i)) )
			text_write_string( in_LogFile, "   " // c_y_VALUE 						// " = " // str_from_real(load_Value_y(i)) )
			text_write_string( in_LogFile, "   " // c_z_VALUE 						// " = " // str_from_real(load_Value_z(i)) )
	END FOR

	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_LOAD) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(load_Count_temp))	
	FOR (i = 1 TO load_Count_temp)
			text_write_string( in_LogFile, "" )	
			text_write_string( in_LogFile, "   " // c_ID 							// " = " // PatranModel.ID_toStr(load_ID(i)) )
			text_write_string( in_LogFile, "   " // c_TYPE 							// " = " // PatranModel.load_Type_toStr(load_Type(i)) )
			text_write_string( in_LogFile, "   " // c_SUBCASE_ID 					// " = " // PatranModel.ID_toStr(load_Subcase_ID(i)) )
			text_write_string( in_LogFile, "   " // c_GEOMETRY_ID 					// " = " // PatranModel.ID_toStr(load_Geometry_ID(i)) )
			text_write_string( in_LogFile, "   " // c_LOAD_VALUE_ID 				// " = " // PatranModel.ID_toStr(load_Value_ID(i)) )
	END FOR
	

	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, c_MATERIAL_LAYUP) 	
	text_write_string( in_LogFile, "   Count: " // str_from_integer(material_layup_Count_temp))	
	FOR (i = 1 TO material_layup_Count_temp)
			text_write_string( in_LogFile, "" )	
			text_write_string( in_LogFile, "   " // c_ID 							// " = " // PatranModel.ID_toStr(material_layup_ID(i, 1)) )

			IF ( PatranModel.ID_toStr(material_layup_ID(i, 2)) > 0 && PatranModel.ID_toStr(material_layup_ID(i, 3)) > 0 ) THEN
				FOR ( i = material_layup_ID(i, 2) TO material_layup_ID(i, 3) )
					text_write_string( in_LogFile, "      " // c_LAYER					// " = " // PatranModel.ID_toStr(layer_ID(i)) )
					text_write_string( in_LogFile, "      " // c_MATERIAL_ID			// " = " // PatranModel.ID_toStr(layer_Material_ID(i)) )
					text_write_string( in_LogFile, "      " // c_THICKNESS				// " = " // str_from_real(layer_Thickness(i)) )
					text_write_string( in_LogFile, "      " // c_ORIENTATION			// " = " // str_from_real(layer_Orientation(i)) )
					text_write_string( in_LogFile, "      " // c_DROP_ORDER			// " = " // str_from_integer(layer_Drop_Order(i)) )
					text_write_string( in_LogFile, "")
				END FOR
			END IF
	END FOR
	
END FUNCTION					
###############################################################################
FUNCTION replaceTabsWithSpaces(in_out_String )


	STRING in_out_String[]
	
	INTEGER index_Tab
	INTEGER tabCount
	INTEGER maxAllowedNumTabs
	
	STRING tabString[8]
	STRING spaceString[8]	
	
	tabString = "	"
	spaceString = " "	
	
	tabCount = 0
	
	# The main purpose of the following line is to prevent an infinite loop
	# when searching for tabs.  An input file typically would have no more than 
	# five tabs per line.  More likely only one tab. If maxAllowedNumTabs is
	# reached it is probably because this function was modified in a way
	# that produced erroneous results
	maxAllowedNumTabs = 100	

	index_Tab = str_index( in_out_String, tabString)
	
	WHILE ( index_Tab > 0  && tabCount < maxAllowedNumTabs )
		str_assign( in_out_String, index_Tab, 1, spaceString )
		index_Tab = str_index( in_out_String, tabString )
		tabCount +=1
	END WHILE

	# WRITE( "!!!!!! Tab Count!!!!!:   " // str_from_integer(tabCount) );	
	
	IF ( tabCount >= maxAllowedNumTabs ) THEN
		return -1
	else 
		return 0
	END IF
	
	
END FUNCTION
###############################################################################
FUNCTION  getBufferNoComments( in_out_buffer, 				@
							 out_ShouldContinue,			@
							 in_ErrorMessages_maxCount,		@
							 in_out_ErrorMessages_current,	@									
							 in_out_errorMessages,			@
							 in_LineNum)



	STRING in_out_buffer[]
	LOGICAL out_ShouldContinue

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_LineNum
	INTEGER returnStatus = 0
	
	STRING  functionName[64] = "getBufferNoComments"	

	out_ShouldContinue = FALSE
	
	# PCL functions str_strip_trail and str_strip_lead do not strip tabs.
	# str_find_nomatch does not seem to work with tabs	
	# Therefore, at the beginning of this function, replace tabs with spaces
	returnStatus = PatranModel.replaceTabsWithSpaces(in_out_buffer)	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not remove all tabs from line: " // str_from_integer(in_LineNum)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
	END IF

	
	in_out_buffer = str_strip_trail (in_out_buffer ) 	
	
	# Skip null lines
	IF ( str_length(in_out_buffer) == 0 ) THEN 
		out_ShouldContinue = TRUE	
		return in_out_buffer
	END IF
	
	# Skip blank lines
	# WRITE( " ")
	# WRITE ("--str_find index:     " // str_from_integer(  str_find_nomatch(in_out_buffer, " " )) )	
	# WRITE ("--str_find_nomatch--: " // in_out_buffer )	
	# IF ( str_equal( in_out_buffer, "	") ) THEN WRITE ("**************** Found Tab ******")
	IF ( str_find_nomatch(in_out_buffer, " " ) == 0 ) THEN
		# All spaces
		out_ShouldContinue = TRUE	
		in_out_buffer = ""
		return in_out_buffer		
	END IF	
	
	
	# remove comment,  Note - comment could be after a valid fields
	in_out_buffer = PatranModel.removeComment(in_out_buffer)
	
	# Check for all blanks
	IF ( str_find_nomatch(in_out_buffer, " " ) == 0 ) THEN
		# All spaces
		out_ShouldContinue = TRUE	
		in_out_buffer = ""
		return in_out_buffer		
	END IF

	in_out_buffer = str_strip_lead (in_out_buffer) 
	in_out_buffer = str_strip_trail (in_out_buffer ) 	
	
	#IF ( !out_ShouldContinue ) THEN
	#	WRITE ("--Should Not Cont Length: " // str_from_integer( str_length( in_out_buffer )) )
	#	WRITE ("--Should Not Continue --: " // in_out_buffer )
	#END IF
	
	return in_out_buffer

END FUNCTION
###############################################################################
# Wherever a "#"  appears the rest of the line is discarded.
FUNCTION removeComment( in_out_String)

	STRING in_out_String[]
	INTEGER indexKey


	indexKey = str_index( in_out_String, "#")

	#WRITE ("--removeComment--: " // str_from_integer( indexKey) )	
	#WRITE ("--removeComment--: " // in_out_String )
	IF ( indexKey > 0 ) THEN
		IF ( indexKey == 1 ) THEN 
			in_out_String = ""
		ELSE
			in_out_String = str_substr( in_out_String, 1, indexKey - 1 )
		END IF
	ENDIF		
	
	
	/**************  
	Don't allow // comments.  This will cause problems for the case where a 
	directory path has double slashes.  This is allowed in directory paths
	indexKey = str_index( in_out_String, "//")
	
	IF ( indexKey > 0 ) THEN
		IF ( indexKey == 1 ) THEN 
			in_out_String = ""
		ELSE
			in_out_String = str_substr( in_out_String, 1, indexKey - 1 )
		END IF
	ENDIF				
	******************/
	
	
	return in_out_String
END FUNCTION	
###############################################################################
# WARNING - This function can only be run after the sys_allocate_array functions have be called
FUNCTION initializeVariables()

	INTEGER I
	FOR ( I = 1 TO disp_Count )
		x_Disp_State_set(i) = FALSE
		y_Disp_State_set(i) = FALSE
		z_Disp_State_set(i) = FALSE
		x_Rot_State_set(i)  = FALSE
		y_Rot_State_set(i)  = FALSE
		z_Rot_State_set(i)  = FALSE						
						
		x_Disp_Val_set(i)   = FALSE
		y_Disp_Val_set(i)   = FALSE
		z_Disp_Val_set(i)   = FALSE
		x_Rot_Val_set(i)    = FALSE
		y_Rot_Val_set(i)    = FALSE
		z_Rot_Val_set(i)    = FALSE						
	END FOR
	
	FOR ( I = 1 TO pin_Count )
		pin_Axial_Rot_State(i) =  c_FREE
		pin_Axial_Disp_State(i) = c_FREE
	END FOR

	FOR ( I = 1 TO load_Count )
		load_Value_Scalar_Set(i) = FALSE
		load_Value_Value_Set(i) =	FALSE
		load_Value_x_Set(i) = 		FALSE
		load_Value_y_Set(i) = 		FALSE
		load_Value_z_Set(i) = 		FALSE
	END FOR
	
	FOR ( I = 1 TO point_Count )
		point_SurfaceInPatranModel(i) =  FALSE
		point_Mdl_SurfaceIDs_index(i) = -1	
	END FOR	
	
	
END FUNCTION

###############################################################################
FUNCTION readAnalysis_NameValPairs( modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)						
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readAnalysis_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	ana_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	
		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )
					CASE (c_ID)
					  ana_ID(ana_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  ana_ID(ana_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF
					CASE (c_DATE)
						ana_DATE(ana_Count_temp) = 	valueField	
					CASE (c_Configuration_ID)
						WRITE ( "                         Found: " //  c_DATE) 
						ana_Configuration_ID(ana_Count_temp) = 	valueField						
					CASE (c_SOURCE_MODEL)
						ana_Source_Model(ana_Count_temp) = 	valueField	
					CASE (c_TYPE)
					  ana_Type(ana_Count_temp) = PatranModel.anaType_toInt (valueField)
					  IF ( ana_Type(ana_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): " // PatranModel.anaType_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF
					   
					CASE (c_SOLVER)	
						ana_Solver(ana_Count_temp) = PatranModel.solver_toInt (valueField)
						 IF ( ana_Solver(ana_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.solver_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
						END IF
				  
					CASE (c_INSTRUCTIONS)			
					  ana_Instructions(ana_Count_temp) = PatranModel.anaInstructions_toInt(valueField)
					  IF (  ana_Instructions(ana_Count_temp) < 0  ) THEN
							addErrorMessage( @
							formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.anaInstructions_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF		
					  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH
				
				#WRITE ( "                         in_out_ErrorMessages_current" // str_from_integer(in_out_ErrorMessages_current) )
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
		WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	
	
END FUNCTION
###############################################################################
FUNCTION readFiles_NameValuePairs( modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readFiles_NameValuePairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	file_Count_temp += 1	

	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )

					CASE (c_PATRAN_MODEL_NAME)
						file_Patran_Model_Name(file_Count_temp) = 	valueField	
					CASE (c_PATRAN_MODEL_DIR)
						file_Patran_Model_Dir(file_Count_temp) = 	valueField		
					CASE (c_PATRAN_MODEL_DIR)
						file_Patran_Model_Dir(file_Count_temp) = 	valueField					
					CASE (c_GEOMETRY_FILE_NAME)
						file_Geometry_File_Name(file_Count_temp) = 	valueField	
					CASE (c_GEOMETRY_FILE_DIR)
						file_Geometry_File_Dir(file_Count_temp) = 	valueField						
						
					CASE (c_GEOMETRY_FILE_TYPE)
					  file_Geometry_File_Type(file_Count_temp) = PatranModel.fileGeometry_File_Type_toInt (valueField)
					  IF ( file_Geometry_File_Type(file_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): " // PatranModel.fileGeometry_File_Type_vStrs()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF 
					  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH
				
				#WRITE ( "                         in_out_ErrorMessages_current" // str_from_integer(in_out_ErrorMessages_current) )
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	

END FUNCTION
###############################################################################
FUNCTION readSubCase_NameValuePairs( modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING 	in_out_Buffer[]
	
	STRING  functionName[64] = "readSubCase_NameValuePairs"		
	
	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	subcase_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE		
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )				
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )
					CASE (c_ID)
					  subcase_ID(subcase_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF ( subcase_ID(subcase_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF

					CASE (c_CONSTRAINT_ID)
					  subcase_Constraint_ID(subcase_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  subcase_Constraint_ID(subcase_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF
					  
					CASE (c_LOAD_ID)
					  subcase_Load_ID(subcase_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  subcase_Load_ID(subcase_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF 				  
							  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH
				
				#WRITE ( "                         in_out_ErrorMessages_current" // str_from_integer(in_out_ErrorMessages_current) )
				
			END IF
		END IF
	END WHILE

	in_out_Buffer = buffer

	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	


END FUNCTION
###############################################################################
FUNCTION readMeshParameters_NameValPairs( modelFile,				@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)			 
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readMeshParameters_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	
	INTEGER realStatus

	STRING nameField[128]
	STRING valueField[128]	
	
	mesh_params_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )
					
					CASE (c_ID)
						mesh_params_ID(mesh_params_Count_temp) =  PatranModel.ID_toInt(valueField)
						IF (  mesh_params_ID(mesh_params_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF

					CASE (c_MAX_GLOBAL_LENGTH)
						mesh_Max_Global_Length(mesh_params_Count_temp) = 	str_to_real(valueField, realStatus)		
						IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
						END IF
						
					CASE (c_MAX_CURV_DELTA_DIV_EDGE_LEN)
						mesh_Max_Curv_Delta_Div_Edge_Ln(mesh_params_Count_temp) = str_to_real(valueField, realStatus)	
						IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
						END IF									
						
					CASE (c_RATIO_MIN_EDGE_TO_MAX_EDGE)
						mesh_Ratio_Min_Edge_To_Max_Edge(mesh_params_Count_temp) = str_to_real(valueField, realStatus)
						IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
						END IF			

					CASE (c_MATCH_FACE_PROXIMITY_TOL)
						mesh_Match_Face_Proximity_Tol(mesh_params_Count_temp) = str_to_real(valueField, realStatus)
						IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
						END IF
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	
	
END FUNCTION
###############################################################################
FUNCTION readMaterial_NameValPairs( modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readMaterial_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	
	INTEGER realStatus

	STRING nameField[128]
	STRING valueField[128]	
	
	mat_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )
					
					CASE (c_ID)
					  mat_ID(mat_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  mat_ID(mat_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF

					CASE (c_NAME)
						mat_Name(mat_Count_temp) = 	valueField					  
					  
					CASE (c_MAT_TROPIC_TYPE)  
					  mat_Tropic_Type(mat_Count_temp) =  PatranModel.mat_Tropic_toInt(valueField)
					  IF (  mat_Tropic_Type(mat_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.mat_Tropic_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF				

					CASE (c_DESCRIPTION)
						mat_Description(mat_Count_temp) = 	valueField						
						
					CASE (c_ELASTIC_MODULUS)
						mat_Elastic_Modulus(mat_Count_temp) = str_to_real(valueField, realStatus)	
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
						END IF						
					CASE (c_POISSONS_RATIO)
						mat_Poissons_Ratio(mat_Count_temp) = str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
						END IF
					CASE (c_DENSITY)
						mat_Density(mat_Count_temp) = str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
						END IF
					CASE (c_THERM_EXPAN_COEF)
						mat_Therm_Expan_Coef(mat_Count_temp) = str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
						END IF
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
		WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )		

END FUNCTION
###############################################################################
FUNCTION readSolid_NameValPairs(	modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages, 			@
									in_out_LineNum,					@
									in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readSolid_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	sol_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )
					
					CASE (c_ID)
					  sol_ID(sol_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  sol_ID(sol_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF
	  
					  
					CASE (c_Element_Type)  
					  sol_Element_Type(sol_Count_temp) =  PatranModel.sol_Element_Type_toInt(valueField)
					  IF (  sol_Element_Type(sol_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.sol_Element_Type_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF				

					CASE (c_Material_ID)  					  
					  sol_Mat_ID(sol_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  sol_Mat_ID(sol_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF					  
					  
					CASE (c_MESH_PARAMETERS_ID) 
					  sol_Mesh_Params_ID(sol_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  sol_Mesh_Params_ID(sol_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF						  
					  					
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
		WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	

END FUNCTION
###############################################################################
FUNCTION readPoint_NameValPairs( 	modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	INTEGER startLineNum
	
	STRING  functionName[64] = "readPoint_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	
	INTEGER realStatus		

	STRING nameField[128]
	STRING valueField[128]	

	logical point_x_undefined = TRUE
	logical point_y_undefined = TRUE
	logical point_z_undefined = TRUE	

	startLineNum = in_out_LineNum
	
	point_Count_temp += 1	

	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )
				
					CASE (c_ID)
					  point_ID(point_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  point_ID(point_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF
	  
					CASE (c_X_Cord)
						point_x(point_Count_temp) = str_to_real(valueField, realStatus)	
						point_x_undefined = FALSE
						IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
						ELSE
							point_x_undefined = FALSE
						END IF
						
						
									
					CASE (c_Y_Cord)
						point_y(point_Count_temp) = str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
						ELSE
							point_y_undefined = FALSE
						END IF
					CASE (c_Z_Cord)
						point_z(point_Count_temp) = str_to_real(valueField, realStatus)						
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
						ELSE
							point_z_undefined = FALSE				  
						END IF
					  					
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	IF ( point_x_undefined || point_y_undefined || point_z_undefined ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "A " // c_POINT // " must have a " // c_X_Cord // ", " // c_Y_Cord // ", and " //  c_Z_Cord // " entries, Line number: "  // str_from_integer(startLineNum)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
	END IF	
		
	in_out_Buffer = buffer
	
		WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	

END FUNCTION
###############################################################################
FUNCTION readGeometry_NameValPairs( modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages, 			@
									in_out_LineNum,					@
									in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readGeometry_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	geometry_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )					
					CASE (c_ID)
					  geometry_ID(geometry_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  geometry_ID(geometry_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  
					
					CASE (c_Type)  
					  geometry_Type(geometry_Count_temp) =  PatranModel.geometry_Type_toInt(valueField)
					  IF (  geometry_Type(geometry_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.geometry_Type_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF				

					CASE (c_Point_ID)  					  
					  geometry_Point_ID(geometry_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  geometry_Point_ID(geometry_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF					  		  		
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	
	
END FUNCTION			
###############################################################################
FUNCTION readDisplacement_NameValPairs( modelFile,						@
										in_ErrorMessages_maxCount,		@	
										in_out_ErrorMessages_current,	@									
										in_out_errorMessages, 			@
										in_out_LineNum,					@
										in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readDisplacement_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	
	INTEGER realStatus

	STRING nameField[128]
	STRING valueField[128]	
	
	disp_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )					
					CASE (c_ID)
					  disp_ID(disp_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  disp_ID(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  
					
					CASE (c_x_Disp_State)  
					  x_Disp_State(disp_Count_temp) =  PatranModel.Fixed_Free_toInt(valueField)
					  IF (  x_Disp_State(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						x_Disp_State_set(disp_Count_temp) = TRUE
					  END IF				

					  
					CASE (c_y_Disp_State)  
					  y_Disp_State(disp_Count_temp) =  PatranModel.Fixed_Free_toInt(valueField)
					  IF (  y_Disp_State(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						y_Disp_State_set(disp_Count_temp) = TRUE									
					  END IF			  
								  
					CASE (c_z_Disp_State)  
					  z_Disp_State(disp_Count_temp) =  PatranModel.Fixed_Free_toInt(valueField)
					  IF (  z_Disp_State(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						z_Disp_State_set(disp_Count_temp) = TRUE
					  END IF							  
					  
					CASE (c_x_Rot_State)  
					  x_Rot_State(disp_Count_temp) =  PatranModel.Fixed_Free_toInt(valueField)
					  IF (  x_Rot_State(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						x_Rot_State_set(disp_Count_temp) = TRUE				
					  END IF				
					  
					CASE (c_y_Rot_State)  
					  y_Rot_State(disp_Count_temp) =  PatranModel.Fixed_Free_toInt(valueField)
					  IF (  y_Rot_State(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						y_Rot_State_set(disp_Count_temp) = TRUE										
					  END IF									  
					  
					CASE (c_z_Rot_State)  
					  z_Rot_State(disp_Count_temp) =  PatranModel.Fixed_Free_toInt(valueField)
					  IF (  z_Rot_State(disp_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						z_Rot_State_set(disp_Count_temp) = TRUE	
					  END IF						  
			  		  		
					#---------------------------------------------------------------------------------------- 

					CASE (c_x_Disp_Val)  
					  x_Disp_Val(disp_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						x_Disp_Val_set(disp_Count_temp) = TRUE
					  END IF				

					  
					CASE (c_y_Disp_Val)  
					  y_Disp_Val(disp_Count_temp) =  str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						y_Disp_Val_set(disp_Count_temp) = TRUE									
					  END IF			  
								  
					CASE (c_z_Disp_Val)  
					  z_Disp_Val(disp_Count_temp) =  str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						z_Disp_Val_set(disp_Count_temp) = TRUE
					  END IF							  
					  
					CASE (c_x_Rot_Val)  
					  x_Rot_Val(disp_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						x_Rot_Val_set(disp_Count_temp) = TRUE				
					  END IF				
					  
					CASE (c_y_Rot_Val)  
					  y_Rot_Val(disp_Count_temp) =  str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						y_Rot_Val_set(disp_Count_temp) = TRUE										
					  END IF									  
					  
					CASE (c_z_Rot_Val)  
					  z_Rot_Val(disp_Count_temp) =  str_to_real(valueField, realStatus)
					   IF (  realStatus != 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not covert value in name-value pair to a floating point number, name-value pair: " // buffer //  ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						z_Rot_Val_set(disp_Count_temp) = TRUE	
					  END IF						
						
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	
	
END FUNCTION
###############################################################################	
FUNCTION readPin_NameValPairs( 	modelFile,						@
								in_ErrorMessages_maxCount,		@	
								in_out_ErrorMessages_current,	@									
								in_out_errorMessages, 			@
								in_out_LineNum,					@
								in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum	
	STRING	in_out_Buffer[]	
	
	STRING  functionName[64] = "readPin_NameValPairs"		
	
	INTEGER length		
	STRING  buffer[2028]
	text_read_string( modelFile, buffer, length )		
	
	in_out_Buffer = buffer	
	
END FUNCTION
###############################################################################
FUNCTION readConstraint_NameValPairs( 	modelFile,						@
										in_ErrorMessages_maxCount,		@	
										in_out_ErrorMessages_current,	@									
										in_out_errorMessages, 			@
										in_out_LineNum,					@
										in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readConstraint_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	constraint_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )					
					CASE (c_ID)
					  constraint_ID(constraint_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  constraint_ID(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  
					
					CASE (c_SubCase_ID)
					  constraint_SubCase_ID(constraint_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  constraint_SubCase_ID(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  					

					CASE (c_GEOMETRY_ID)
					  constraint_Geometry_ID(constraint_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  constraint_SubCase_ID(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF									
					
					CASE (c_Type)  
						constraint_Type(constraint_Count_temp) =  PatranModel.constraint_Type_toInt(valueField)
						IF (  constraint_Type(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.constraint_Type_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF				

					CASE (c_DISPLACEMENT_ID)  					  
						constraint_Displacement_ID(constraint_Count_temp) =  PatranModel.ID_toInt(valueField)
						IF (  constraint_Displacement_ID(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF	
					CASE (c_PIN_ID)  					  
						constraint_Pin_ID(constraint_Count_temp) =  PatranModel.ID_toInt(valueField)
						IF (  constraint_Pin_ID(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF					  		  		
					CASE (c_BALL_ID)  					  
						constraint_Ball_ID(constraint_Count_temp) =  PatranModel.ID_toInt(valueField)
						IF (  constraint_Ball_ID(constraint_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF					  		  							  
					  					  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	
	
END FUNCTION
###############################################################################		
FUNCTION readLoadValue_NameValPairs( 	modelFile,						@
										in_ErrorMessages_maxCount,		@	
										in_out_ErrorMessages_current,	@									
										in_out_errorMessages, 			@
										in_out_LineNum,					@
										in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	INTEGER in_out_LineNum
	STRING	in_out_Buffer[]
	
	STRING  functionName[64] = "readLoadValue_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	
	INTEGER realStatus

	STRING nameField[128]
	STRING valueField[128]	
	
	load_Value_Count_temp += 1	
	
	buffer = ""
	WHILE ( equalsSignFound )	

		INTEGER textReadStatus
		textReadStatus = text_read_string( modelFile, buffer, length )
		IF ( textReadStatus != 0 ) THEN
			buffer = ""
			IF ( textReadStatus == -1 ) THEN
				equalsSignFound = FALSE
			ENDIF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )

				SWITCH ( nameField )					
					CASE (c_ID)
					  load_Value_ID(load_Value_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  load_Value_ID(load_Value_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  
					  		  							  
					CASE (c_SCALAR_VALUE)  
					  load_value_Scalar(load_Value_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  load_value_Scalar(load_Value_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						load_Value_Scalar_Set(load_Value_Count_temp) = TRUE
					  END IF
										
					CASE (c_VALUE)  
					  load_Value_Value(load_Value_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  load_Value_Value(load_Value_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						load_Value_Value_Set(load_Value_Count_temp) = TRUE
					  END IF
					    			
					CASE (c_x_VALUE)  
					  load_Value_x(load_Value_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  load_Value_x(load_Value_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						load_Value_x_Set(load_Value_Count_temp) = TRUE
					  END IF
					  								
					CASE (c_y_VALUE)  
					  WRITE ( "Function: " // functionName  // ", y_Value: " // valueField )	
					  REAL TestY
					  TestY = str_to_real(valueField, realStatus)
					  load_Value_y(load_Value_Count_temp) =  str_to_real(valueField, realStatus)
					  WRITE ( "Function: " // functionName  // ", y_Value: " // str_from_real(load_Value_y(load_Value_Count_temp)) )	
					  WRITE ( "Function: " // functionName  // ", y_Value: " // str_from_real(TestY) )
					  IF (  load_Value_y(load_Value_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						load_Value_y_Set(load_Value_Count_temp) = TRUE
					  END IF								

					CASE (c_z_VALUE)  
					  load_Value_z(load_Value_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  load_Value_z(load_Value_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.Fixed_Free_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  ELSE
						load_Value_z_Set(load_Value_Count_temp) = TRUE
					  END IF	
											  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF
		END IF
	END WHILE
		
	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	

	
END FUNCTION
###############################################################################		
FUNCTION readLoad_NameValPairs( 	modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)			
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()	
	INTEGER in_out_LineNum		
	STRING	in_out_Buffer[]	

	
	STRING  functionName[64] = "readLoad_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	load_Count_temp += 1	

	buffer = ""
	WHILE ( equalsSignFound )	
		INTEGER readStrStatus
		readStrStatus = text_read_string( modelFile, buffer, length )
		IF ( readStrStatus != 0 ) THEN
			buffer = ""
			IF (readStrStatus == -1) THEN
				equalsSignFound = FALSE
			END IF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE					
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )
				SWITCH ( nameField )					
					CASE (c_ID)
					  load_ID(load_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  load_ID(load_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  
					  		  							  
					CASE (c_SubCase_ID)
					  load_SubCase_ID(load_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  load_SubCase_ID(load_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF 

					  CASE (c_GEOMETRY_ID)
					  load_Geometry_ID(load_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  load_Geometry_ID(load_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF
										
					CASE (c_LOAD_VALUE_ID)
					  load_Load_Value_ID(load_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  load_Load_Value_ID(load_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF 
										
					CASE (c_Type)  
						load_Type(load_Count_temp) =  PatranModel.load_Type_toInt(valueField)
						IF (  load_Type(load_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Invalid value in name-value pair: " // buffer // ", Valid value(s): "  // PatranModel.constraint_Type_validStrings()  // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF	  					    			
											  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	

				
			END IF

		END IF

	END WHILE		


	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	



END FUNCTION
###############################################################################	
FUNCTION readMaterialLayup_NameValPairs( 	modelFile,						@
											in_ErrorMessages_maxCount,		@	
											in_out_ErrorMessages_current,	@									
											in_out_errorMessages,			@
											in_out_LineNum,					@
											in_out_Buffer)

	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()	
	INTEGER in_out_LineNum		
	STRING	in_out_Buffer[]	

	
	STRING  functionName[64] = "readMaterialLayup_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	

	STRING nameField[128]
	STRING valueField[128]	
	
	material_layup_Count_temp += 1

	buffer = ""
	WHILE ( equalsSignFound )	
		INTEGER readStrStatus
		readStrStatus = text_read_string( modelFile, buffer, length )
		IF ( readStrStatus != 0 ) THEN
			buffer = ""
			IF (readStrStatus == -1) THEN
				equalsSignFound = FALSE
			END IF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE	
				
				# Check if it's a Layer tag
				WHILE ( buffer == c_Layer)
					PatranModel.readLayer_NameValPairs(   @
					modelFile, in_ErrorMessages_maxCount, in_out_ErrorMessages_current,	in_out_errorMessages, in_out_LineNum, buffer)

					IF (material_layup_ID(material_layup_Count_temp, 2) == 0) THEN
						material_layup_ID(material_layup_Count_temp, 2) = layer_Count_temp
					END IF

					material_layup_ID(material_layup_Count_temp, 3) = layer_Count_temp	

				END WHILE	
		
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )
				SWITCH ( nameField )					
					CASE (c_ID)
					  material_layup_ID(material_layup_Count_temp, 1) =  PatranModel.ID_toInt(valueField)
					  material_layup_ID(material_layup_Count_temp, 2) = 0
					  material_layup_ID(material_layup_Count_temp, 3) = 0
					  IF (  material_layup_ID(material_layup_Count_temp, 1) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF 
								    			
											  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	

				
			END IF

		END IF

	END WHILE		


	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	


END FUNCTION

###############################################################################		
FUNCTION readLayer_NameValPairs( 	modelFile,						@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages,			@
									in_out_LineNum,					@
									in_out_Buffer)

						
	INTEGER modelFile
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()	
	INTEGER in_out_LineNum		
	STRING	in_out_Buffer[]	

	
	STRING  functionName[64] = "readLayer_NameValPairs"		

	LOGICAL equalsSignFound = TRUE
	LOGICAL	shouldContinue
	STRING  buffer[2028]	
	
	INTEGER length	
	INTEGER realStatus

	STRING nameField[128]
	STRING valueField[128]	

	layer_Count_temp += 1

	buffer = ""

	WHILE ( equalsSignFound )
		INTEGER readStrStatus
		readStrStatus = text_read_string( modelFile, buffer, length )
		IF ( readStrStatus != 0 ) THEN
			buffer = ""
			IF (readStrStatus == -1) THEN
				equalsSignFound = FALSE
			END IF
		ELSE
			in_out_LineNum += 1
			shouldContinue = FALSE			
			
			buffer = PatranModel.getBufferNoComments( buffer, shouldContinue, in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages, in_out_LineNum  )					
			# shouldContinue == TRUE means that the line was blank or contained only a comment
			If (shouldContinue ) THEN CONTINUE 
			
			IF ( str_index( buffer, "=" ) == 0 ) THEN
				equalsSignFound = FALSE	
			ELSE
				nameField = str_token( buffer,"=", 1, TRUE )		
				valueField = str_token( buffer,"=", 2, TRUE )
				SWITCH ( nameField )					
					CASE (c_ID)
					  layer_ID(layer_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  layer_ID(layer_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
					  END IF  		    			
							
					CASE (c_MATERIAL_ID)
					  layer_material_ID(layer_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  layer_material_ID(layer_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
					  END IF

					 CASE (c_ORIENTATION)
					  layer_Orientation(layer_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  layer_Orientation(layer_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
					  END IF	

					  CASE (c_THICKNESS)
					  layer_Thickness(layer_Count_temp) =  str_to_real(valueField, realStatus)
					  IF (  layer_Thickness(layer_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
					  END IF	

					  CASE (c_DROP_ORDER)
					  layer_Drop_Order(layer_Count_temp) =  PatranModel.ID_toInt(valueField)
					  IF (  layer_Drop_Order(layer_Count_temp) < 0 ) THEN
							addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Could not convert to a positive non-zero integer, String: " // valueField // ", Line number: " // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
					  END IF	
					   		  
					DEFAULT
						addErrorMessage( @
								formatErrorMessage( c_ERROR, functionName, "Unexpected name-value pair: " // buffer // ", Line number: "  // str_from_integer(in_out_LineNum)), @
									in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 						
				END SWITCH	
				
			END IF

		END IF


	END WHILE

	in_out_Buffer = buffer
	
	WRITE ( "Function: " // functionName  // ", Returned Buffer: " // buffer )	

END FUNCTION

###############################################################################	

#	*******************************
#   Various Checker Functions
#	*******************************

###############################################################################	
FUNCTION checkDataStructure (	in_ErrorMessages_maxCount,		@	
								in_out_ErrorMessages_current,	@									
								in_out_errorMessages)

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	STRING  functionName[64] = "checkDataStructure"		

   	INTEGER returnStatus = 0
  	INTEGER tempReturnStatus = 0	
		
	# There must be at least one Solid,  later at least one solid or one surface.  For now just check for a solid
	IF (sol_count < 1 ) THEN
		addErrorMessage( @
						formatErrorMessage( c_ERROR, functionName, "Zero solids found in input file. There must be at least one solid."), @
						in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
		returnStatus = -1
	END IF
	
	
	#This check needs to be replaced with a check that verifies that the Load/Constraint points
	# to a valid SubCase_ID
	#tempReturnStatus = PatranModel.checkSubcase(	in_ErrorMessages_maxCount,		@
	#							in_out_ErrorMessages_current,	@
	#							in_out_errorMessages)
	#IF ( tempReturnStatus != 0 ) THEN
	#	returnStatus = -1
	#END IF
								
	tempReturnStatus = PatranModel.checkSolid(		in_ErrorMessages_maxCount,		@
								in_out_ErrorMessages_current,	@
								in_out_errorMessages)

	IF ( tempReturnStatus != 0 ) THEN 
		returnStatus = -1
	END IF								
								
	tempReturnStatus = PatranModel.checkLoad(		in_ErrorMessages_maxCount,		@
								in_out_ErrorMessages_current,	@
								in_out_errorMessages)
	IF ( tempReturnStatus != 0 ) THEN 
		returnStatus = -1
	END IF
								
	tempReturnStatus = PatranModel.checkConstraint(	in_ErrorMessages_maxCount,		@
									in_out_ErrorMessages_current,	@
									in_out_errorMessages)
	IF ( tempReturnStatus != 0 ) THEN 
		returnStatus = -1
	END IF
	tempReturnStatus = PatranModel.checkLayer(		in_ErrorMessages_maxCount,		@
								in_out_ErrorMessages_current,	@
								in_out_errorMessages)
	IF ( tempReturnStatus != 0 ) THEN 
		returnStatus = -1
	END IF								

	return returnStatus
END FUNCTION
###############################################################################	
FUNCTION checkSubcase(	in_ErrorMessages_maxCount,		@	
						in_out_ErrorMessages_current,	@									
						in_out_errorMessages)

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
		
	STRING functionName[64] = "checkSubcase"
	Integer i

	INTEGER returnStatus = 0
	
	FOR ( i = 1 TO subcase_Count_temp )
		IF ( PatranModel.checkConstraint_HasID( subcase_Constraint_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Subcase ID: " // str_from_integer(subcase_ID(i)) // ", missing Constraint with ID: "  // str_from_integer(subcase_Constraint_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
			returnStatus = -1
		END IF

		IF ( PatranModel.checkLoad_HasID( subcase_Load_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Subcase ID: " // str_from_integer(subcase_ID(i)) // ", missing Load with ID: "  // str_from_integer(subcase_Load_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
			returnStatus = -1
		END IF

	END FOR

	return returnStatus
END FUNCTION
###############################################################################
FUNCTION checkSolid (	in_ErrorMessages_maxCount,		@	
						in_out_ErrorMessages_current,	@									
						in_out_errorMessages)

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
		
	INTEGER returnStatus = 0		
		
	STRING functionName[64] = "checkSolid"
	Integer i

	FOR ( i = 1 TO sol_Count_temp )
		IF ( PatranModel.checkMaterial_HasID(sol_Mat_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Solid ID: " // str_from_integer(sol_ID(i)) // ", missing Material with ID: "  // str_from_integer(sol_Mat_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
			returnStatus = -1							
		END IF

		IF ( PatranModel.checkMeshParameter_HasID(sol_Mesh_Params_ID(i))  == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Solid ID: " // str_from_integer(sol_ID(i)) // ", missing Mesh Parameter with ID: "  // str_from_integer(sol_Mesh_Params_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
			returnStatus = -1				
		END IF
	END FOR


	INTEGER elementType = 0
	IF ( sol_Count_temp > 0) THEN
		elementType = sol_Element_Type(1)
	END IF
		
	FOR ( i = 1 TO sol_Count_temp )
		IF ( sol_Element_Type(i) != elementType ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "mixed element types: " // PatranModel.sol_Element_Type_toStr(sol_Element_Type(i)) // ", Solid ID: "  // str_from_integer(sol_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
			returnStatus = -1
		END IF	
	END FOR


	# uncomment when we can mix TETRA4 with TETRA8 and CQUAD4 with CQUAD8
	#STRING elementType[64] = ""
	#IF ( sol_Count_temp > 0) THEN
	#	elementType = PatranModel.sol_Element_Type_toStr(sol_Element_Type(1))
	#	IF ( str_index( elementType, "TETRA" ) == 0 ) THEN
	#		elementType = "CQUAD"
	#	END IF
	#END IF
	#FOR ( i = 1 TO sol_Count_temp )
	#	IF ( str_index( PatranModel.sol_Element_Type_toStr(sol_Element_Type(i)) , elementType ) == 0 ) THEN
	#		addErrorMessage( @
	#				formatErrorMessage( c_ERROR, functionName, "mixed element types: " // PatranModel.sol_Element_Type_toStr(sol_Element_Type(i)) // ", Solid ID: "  // str_from_integer(sol_ID(i))), @
	#						in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
	#	END IF
	#END FOR

	return returnStatus

END FUNCTION
###############################################################################
FUNCTION checkLoad (	in_ErrorMessages_maxCount,		@	
						in_out_ErrorMessages_current,	@									
						in_out_errorMessages)

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()

	STRING functionName[64] = "checkLoad"
	Integer i
	INTEGER returnStatus = 0	
	
	FOR ( i = 1 TO load_Count_temp )
		IF ( PatranModel.checkSubcase_HasID(load_SubCase_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Load ID: " // str_from_integer(load_ID(i)) // ", missing Subcase with ID: "  // str_from_integer(load_SubCase_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
			returnStatus = -1				
			
		END IF

		IF ( PatranModel.checkGeometry_HasID(load_Geometry_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Load ID: " // str_from_integer(load_ID(i)) // ", missing Geometry with ID: "  // str_from_integer(load_Geometry_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
			returnStatus = -1				
		END IF

		IF ( PatranModel.checkLoadValue_HasID(load_Load_Value_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Load ID: " // str_from_integer(load_ID(i)) // ", missing Load Value with ID: "  // str_from_integer(load_Load_Value_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 	
			returnStatus = -1				
		END IF

	END FOR

	return returnStatus
END FUNCTION
###############################################################################
FUNCTION checkConstraint (	in_ErrorMessages_maxCount,		@	
							in_out_ErrorMessages_current,	@									
							in_out_errorMessages)

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()

	STRING functionName[64] = "checkConstraint"
	Integer i
	INTEGER returnStatus = 0		

	FOR ( i = 1 TO constraint_Count_temp )
		IF ( PatranModel.checkSubcase_HasID(constraint_SubCase_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Constraint ID: " // str_from_integer(load_ID(i)) // ", missing Subcase with ID: "  // str_from_integer(constraint_SubCase_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
			returnStatus = -1		
		END IF

		IF ( PatranModel.checkGeometry_HasID(constraint_Geometry_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Constraint ID: " // str_from_integer(load_ID(i)) // ", missing Geometry with ID: "  // str_from_integer(constraint_Geometry_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
			returnStatus = -1		
		END IF

		# only displacement is supported currently
		IF ( PatranModel.checkDisplacement_HasID(constraint_Displacement_ID (i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Constraint ID: " // str_from_integer(load_ID(i)) // ", missing Diplacement with ID: "  // str_from_integer(constraint_Displacement_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
			returnStatus = -1	
		END IF
	END FOR

	return returnStatus
	
END FUNCTION
###############################################################################
FUNCTION checkLayer (	in_ErrorMessages_maxCount,		@	
						in_out_ErrorMessages_current,	@									
						in_out_errorMessages)

	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()

	STRING functionName[64] = "checkLayer"
	Integer i
	INTEGER returnStatus = 0		

	FOR ( i = 1 TO layer_Count_temp )
		IF ( PatranModel.checkMaterial_HasID(layer_Material_ID(i)) == FALSE ) THEN
			addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "Layer ID: " // str_from_integer(load_ID(i)) // ", missing Material with ID: "  // str_from_integer(constraint_SubCase_ID(i))), @
							in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages ) 
			returnStatus = -1								
		END IF
	END FOR
	return returnStatus
END FUNCTION

###############################################################################
FUNCTION checkConstraint_HasID( id_to_search )

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	Integer i	

	FOR ( i = 1 TO constraint_Count )
		IF ( constraint_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR

	return result

END FUNCTION
###############################################################################	
FUNCTION checkLoad_HasID( id_to_search )

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	Integer i

	FOR ( i = 1 TO load_Count )
		IF ( load_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################	
FUNCTION checkMeshParameter_HasID( 		id_to_search)

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	STRING  functionName[64] = "checkMeshParameter_HasID"
	Integer i

	FOR ( i = 1 TO mesh_params_Count_temp )
		IF ( mesh_params_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################	
FUNCTION checkMaterial_HasID( 		id_to_search)

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	STRING  functionName[64] = "checkMaterial_HasID"
	Integer i

	FOR ( i = 1 TO mat_Count_temp )
		IF ( mat_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################	
FUNCTION checkSubcase_HasID ( id_to_search )

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	STRING  functionName[64] = "checkSubcase_HasID"
	Integer i

	FOR ( i = 1 TO subcase_Count_temp )
		IF ( subcase_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################	
FUNCTION checkGeometry_HasID ( id_to_search )

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	STRING  functionName[64] = "checkGeometry_HasID"
	Integer i

	FOR ( i = 1 TO geometry_Count_temp )
		IF ( geometry_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################	
FUNCTION checkLoadValue_HasID ( id_to_search )

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	STRING  functionName[64] = "checkLoadValue_HasID"
	Integer i

	FOR ( i = 1 TO load_Value_Count_temp )
		IF ( load_Value_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################	
FUNCTION checkDisplacement_HasID ( id_to_search )

	INTEGER	id_to_search
	LOGICAL	result 
	result = FALSE

	STRING  functionName[64] = "checkDisplacement_HasID"
	Integer i

	FOR ( i = 1 TO disp_Count_temp )
		IF ( disp_ID(i) == id_to_search ) THEN
			result = TRUE
			BREAK
		END IF
	END FOR
	return result

END FUNCTION
###############################################################################
FUNCTION createPatranDB (	in_File_Patran_Model_Name, 			@
							in_File_Patran_Model_Dir, 			@
							in_logFile, 						@
							in_ErrorMessages_maxCount,			@	
							in_out_ErrorMessages_current,		@									
							in_out_errorMessages )		
						
	# If the Patran DB exists, this function will not overwrite it
    STRING 	in_File_Patran_Model_Name[]
    STRING 	in_File_Patran_Model_Dir[]
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	
	INTEGER returnStatus = 0;
	
	STRING functionName[64] = "createPatranDB"
	
	# If DB open, close it.  No DBs should be open.  Put this here in case this function is reused elsewhere.
    uil_file_close.go(  )		
	
	returnStatus = uil_file_new.go( "", in_File_Patran_Model_Dir // "\" // in_File_Patran_Model_Name )
	
    IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not create DB (uil_file_new.go), DB: " // in_File_Patran_Model_Dir // "\" // in_File_Patran_Model_Name// ", Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus	
    END IF		
	
	text_write_string( in_LogFile, "Created Patran DB: " // in_File_Patran_Model_Dir // "\" // in_File_Patran_Model_Name)	
	
    RETURN returnStatus

END FUNCTION	
###############################################################################	
FUNCTION setPatranWorkingDir (	in_File_Patran_Model_Dir, 			@
								in_logFile, 						@
								in_ErrorMessages_maxCount,			@	
								in_out_ErrorMessages_current,		@									
								in_out_errorMessages )		
						

						
    STRING 	in_File_Patran_Model_Dir[]
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	
	INTEGER returnStatus = 0;
	
	STRING functionName[64] = "setPatranWorkingDir"
	
    returnStatus = set_current_dir( in_File_Patran_Model_Dir )	
 	
    IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not set Patran working directory, Dir: " // in_File_Patran_Model_Dir // ", Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus	
    END IF		
	
	text_write_string( in_LogFile, "Set Patran working directory: " // in_File_Patran_Model_Dir) 		
	
    RETURN returnStatus

END FUNCTION	

###############################################################################	
FUNCTION importParasolidFile (	in_File_Parasolid_Model_Name, 			@
								in_File_Parasolid_Model_Dir, 			@
								in_Unit_Conversion_Factor,				@
								in_logFile, 							@
								in_ErrorMessages_maxCount,				@	
								in_out_ErrorMessages_current,			@									
								in_out_errorMessages )							

#   Parasolid Models are always in meters
#   in_Unit_Conversion_Factor = 1000, mm
#   in_Unit_Conversion_Factor = 1, m
#   in_Unit_Conversion_Factor = 39.370079, inch
							
								
    STRING 	in_File_Parasolid_Model_Name[]
    STRING 	in_File_Parasolid_Model_Dir[]
	INTEGER in_LogFile		
	REAL	in_Unit_Conversion_Factor
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()							
													
	STRING parasolidFile_DirAndFileName[1024] 	
	
	parasolidFile_DirAndFileName = in_File_Parasolid_Model_Dir // "\" // in_File_Parasolid_Model_Name
	
	STRING functionName[64] = "importParasolidFile"
	
	# The following arrays and array sizes were taken from a session file.
	# Tried using VIRTUAL but VIRTUAL did not work
	INTEGER uil_file_import_ps_tr_xmt_count(5)
	INTEGER uil_file_import_ps_patran_count(4)
	INTEGER uil_file_import_ps_tra_n_layers
	INTEGER uil_file_import_ps_tr_layer_ids(5,256)
	REAL uil_file_import_ps_tr_model_tol(2)
	
	INTEGER returnStatus 
 
	REAL transformation(12) = [ 1000.0, 0., 0., 0., 1000.0, 0., 0., 0.,1000.0, 0., 0., 0. ]
	
	transformation(1) = in_Unit_Conversion_Factor
	transformation(5) = in_Unit_Conversion_Factor
	transformation(9) = in_Unit_Conversion_Factor
	
	
	p3_express_options_file( "express.opt", FALSE, 3, 1, 52054, TRUE, transformation, 0, ["0"], [[-1]], [[-1]], [[-1] @
	], TRUE, [0], TRUE, [0], TRUE, [0], 3, 1, 1 )						 
					 
	returnStatus = p3_ug_xmt_import_v2( parasolidFile_DirAndFileName, "", "express.opt", TRUE, 32,  @
							uil_file_import_ps_tr_xmt_count, uil_file_import_ps_patran_count,  @
							uil_file_import_ps_tra_n_layers, uil_file_import_ps_tr_layer_ids,  @
							uil_file_import_ps_tr_model_tol, TRUE, "", FALSE )
			 
						 
    IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "Could not import Parasolid file (p3_ug_xmt_import_v2), File: " // parasolidFile_DirAndFileName // ", Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus	
    END IF	
	
		
	# DUMP  uil_file_import_ps_tr_xmt_count
	INTEGER i
	
	text_write_string ( in_LogFile, "" )		
	text_write_string ( in_LogFile, "Imported Parasolid File:" )	
	text_write( in_LogFile, "    Parasolid File:     %A%",0,0.0, parasolidFile_DirAndFileName)	
	text_write_string ( in_LogFile, "    uil_file_import_ps_tr_xmt_count:" )	
	FOR ( i = 1 TO 5 BY 1 )
		text_write( in_LogFile, "        %I%",uil_file_import_ps_tr_xmt_count(i),0.0,"")
	END FOR
	text_write_string ( in_LogFile, "    uil_file_import_ps_patran_count:" )	
	FOR ( i = 1 TO 4 BY 1 )
		text_write( in_LogFile, "        %I%",uil_file_import_ps_patran_count(i),0.0,"")
	END FOR	

	RETURN returnStatus
	
END FUNCTION
#############################################################################################
FUNCTION createMaterials_MAT1( 	in_Mat_Name,					@	
								in_Mat_Description,				@
								in_Mat_ElasticModulus,			@
								in_Mat_PoissonsRatio,			@
								in_Mat_Density,					@
								in_Mat_ThermExpanCoef,			@
								in_logFile, 					@
								in_ErrorMessages_maxCount,		@	
								in_out_ErrorMessages_current,	@									
								in_out_errorMessages )		
	STRING 	in_Mat_Name[]
	STRING 	in_Mat_Description[]
	REAL 	in_Mat_ElasticModulus
	REAL 	in_Mat_PoissonsRatio
	REAL 	in_Mat_Density
	REAL 	in_Mat_ThermExpanCoef		
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()		
	
	STRING functionName[64] = "CreateMaterials_MAT1"
	INTEGER returnStatus = 0	
	
	STRING tempString[1024]
			
	/**********  Original Copied from session file *******
	material.create( "Analysis code ID", 1, "Analysis type ID", 1,  @
	"steel_stainless_321", 0, "Date: 20-Jul-15           Time: 12:56:25",  @
	"Isotropic", 1, "Directionality", 1, "Linearity", 1, "Homogeneous", 0,  @
	"Linear Elastic", 1, "Model Options & IDs", ["", "", "", "", ""], [0, 0, 0, 0, @
	 0], "Active Flag", 1, "Create", 10, "External Flag", FALSE, "Property IDs", [ @
	"Elastic Modulus", "Poisson Ratio", "Density", "Thermal Expan. Coeff"], [2, 5, @
	 16, 24, 0], "Property Values", ["1.99948E8", ".27", "7.82708E-6", "1.17E-5",  @
	""] )
	****************/

	text_write_string ( in_LogFile, "" )		

	# Property ID 	Property Name   		 See: PCL Reference Manual Volume 1: Function Descriptions
	# ------------- -------------------
	# 2 			Elastic Modulus
	# 5 			Poisson Ratio		
	# 16 			Density
	# 24 			Thermal Expansion Coeff
	
	STRING PropertyValues[32](5)		
	PropertyValues(1) = str_from_real(in_Mat_ElasticModulus)
	PropertyValues(2) = str_from_real(in_Mat_PoissonsRatio)
	PropertyValues(3) = str_from_real(in_Mat_Density)
	PropertyValues(4) = str_from_real(in_Mat_ThermExpanCoef)
	PropertyValues(5) =	""	
	

	returnStatus = material.create( "Analysis code ID", 1, "Analysis type ID", 1,  @
	in_Mat_Name, 0, in_Mat_Description,  @
	"Isotropic", 1, "Directionality", 1, "Linearity", 1, "Homogeneous", 0,  @
	"Linear Elastic", 1, "Model Options & IDs", ["", "", "", "", ""], [0, 0, 0, 0, @
	 0], "Active Flag", 1, "Create", 10, "External Flag", FALSE, "Property IDs", [ @
	"Elastic Modulus", "Poisson Ratio", "Density", "Thermal Expan. Coeff"], [2, 5, @
	16, 24, 0], "Property Values", PropertyValues )		
		
		
	IF ( returnStatus != 0 ) THEN	
		tempString = "Function: " // functionName // ", ERROR - Could not create material, Material Name, ElasticModulus, PoissonsRatio, Density, ThermExpanCoef: " @			
		// str_from_real(in_Mat_Name) // ", " @
		// str_from_real(in_Mat_ElasticModulus) // ", " @
		// str_from_real(in_Mat_PoissonsRatio) // ", " @
		// str_from_real(in_Mat_Density) // ", " @
		// str_from_real(in_Mat_ThermExpanCoef)
		
		addErrorMessage( @
		   formatErrorMessage( c_ERROR, functionName, tempString), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 


		RETURN returnStatus
	ELSE
		text_write( in_LogFile, "Created Material:",0,0.0,"")	
		text_write( in_LogFile, "    Material Name used in Patran Model: %A%",0,0.0, in_Mat_Name)					
		text_write( in_LogFile, "    ElasticModulus:    %E%",0,in_Mat_ElasticModulus,"")
		text_write( in_LogFile, "    PoissonsRatio:    %E%",0,in_Mat_PoissonsRatio,"")			
		text_write( in_LogFile, "    Density:          %E%",0,in_Mat_Density,"")
		text_write( in_LogFile, "    ThermExpanCoef:   %E%",0,in_Mat_ThermExpanCoef,"")
	END IF
	
	
	RETURN returnStatus

END FUNCTION
#############################################################################################
FUNCTION buildNameString ( in_PrefixString, in_Number, in_PostfixString, in_MaxLength )

	STRING 	in_PrefixString[]
	INTEGER in_Number
	STRING 	in_PostfixString[]	
	INTEGER	in_MaxLength
	
	STRING tempString[1024]

	tempString = in_PrefixString // str_from_integer(in_Number) // in_PostfixString
	
	RETURN str_substr( tempString, 1 , in_MaxLength )
	
	
END FUNCTION
#############################################################################################
# The materials (createMaterials_MAT1() function) MUST BE CALLED before calling this function.
FUNCTION createPropertySet_PSolid( 	in_ParasolidIndex, 				@
									in_Material_Name,  				@
									in_InPatranSolidName,			@
									in_logFile, 					@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages )											

	INTEGER in_ParasolidIndex

	STRING 	in_Material_Name[]
	STRING 	in_InPatranSolidName[]	
	
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()		

	STRING popertySetName[31] 
	popertySetName = PatranModel.buildNameString ( "P", in_ParasolidIndex, "_Solid_" // in_Material_Name, 31 )
	
	STRING functionName[64] = "createPropertySet_PSolid"

	/********** from the session file
	elementprops_create( "Prop_Set_1", 71, 25, 30, 1, 1, 20, [13, 21, 4124, 4126,  @
	4125, 8111], [5, 4, 4, 4, 4, 4], ["m:steel_filler_weld_070ksi", "", "", "", "" @
	, ""], "Solid 1" )
	
	Another example
	elementprops_create( "Prop_Set_Name_2", 71, 25, 30, 1, 1, 20, [13, 21, 4124,  @
	4126, 4125, 8111, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4410, 4411], [5,  @
	4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 6], ["m:M2_low_alloy_steel_a515_gr70",  @
	"", "", "", "", "", "", "", "", "", "", "", "", "", ""], "Solid 1" )
	
	***********/
		
	INTEGER returnStatus = 0

	STRING propertyData[256](6)		
	propertyData(2) =	""	
	propertyData(3) =	""
	propertyData(4) =	""
	propertyData(5) =	""
	propertyData(6) =	""		
	
	
	propertyData(1) = "m:" // in_Material_Name
	
	returnStatus = elementprops_create( popertySetName, 71, 25, 30, 1, 1, 20, [13, 21, 4124, 4126,  @
	4125, 8111], [5, 4, 4, 4, 4, 4], propertyData, in_InPatranSolidName )			
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "Could not create property set. popertySetName, material name, solidName: " // @
			popertySetName // "  " // propertyData(1) // "  " // in_InPatranSolidName // " , Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
		
	ELSE			
		text_write_string ( in_LogFile, "" )			
		text_write_string ( in_LogFile, "Created ElementProp (i.e. PSolid card) :" )	
		text_write( in_LogFile, "    Property Set Name: %A%",0,0.0, popertySetName)	
		text_write( in_LogFile, "    Material Name:     %A%",0,0.0, propertyData(1))
		text_write( in_LogFile, "    Solid Name:        %A%",0,0.0, in_InPatranSolidName )			
	END IF
		
	
	RETURN returnStatus
	
END FUNCTION

#############################################################################################
FUNCTION getModelSolidCount( 	out_Mdl_SolidCount, 		    @
 									in_logFile, 					@
									in_ErrorMessages_maxCount,		@	
									in_out_ErrorMessages_current,	@									
									in_out_errorMessages )			

	INTEGER	out_Mdl_SolidCount			
	
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()		
	
	STRING functionName[64] = "getModelSolidCount"	

	INTEGER returnStatus = 0	
	INTEGER mdl_solid_count= 0	
	
	STRING list_entities[64]	
	
	list_entities = "Solid 1:#"
		
	###################
	# Get Solid Count
	###################
	
	mdl_solid_count = fem_u_count_id_list( ci_LP_SUBLIST_SOLID , list_entities, FALSE, returnStatus )
	
	text_write_string ( in_LogFile, "" )	
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "fem_u_count_id_list returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF
	
	if ( mdl_solid_count <= 0 ) THEN
		text_write_string ( in_LogFile, "" )			
		text_write_string ( in_LogFile, c_WARNING // ", " // functionName // ", No solids found in Patran model."  )	
		# This is not an error. The model could contain no solids.  There should be either solids or surfaces in the model. 
		# Note - Surfaces are retrieved in another function.
		RETURN returnStatus	
	END IF
		
	out_Mdl_SolidCount = mdl_solid_count
		
    RETURN returnStatus	
	
END FUNCTION
#############################################################################################
FUNCTION getModelSolidIDsAndFaceIDs( 										@
										in_Mdl_SolidCount,					@
										out_Mdl_SolidIDs, 					@
										out_Mdl_NumberSolidFaces,			@ 												
										in_LogFile, 						@
										in_ErrorMessages_maxCount,			@	
										in_out_ErrorMessages_current,		@									
										in_out_errorMessages )	
	INTEGER	in_Mdl_SolidCount
	INTEGER	out_Mdl_SolidIDs()		
	INTEGER out_Mdl_NumberSolidFaces()
	
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()		
	
	STRING functionName[64] = "getModelSolidIDsAndFaceIDs"	

	INTEGER returnStatus = 0	
		
	INTEGER num_faces
	
	STRING list_entities[64]	
	
	list_entities = "Solid 1:#"
	
	INTEGER solid_Ids(VIRTUAL)
	INTEGER i

	###############################
	# Allocate Array for Solid IDs
	###############################	
	
	returnStatus = sys_allocate_array(solid_Ids, 1, in_Mdl_SolidCount)
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "sys_allocate_array for allocating solid_Ids array returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF	

	###################
	# Get Solid IDs
	###################		
	
	returnStatus =  fem_u_get_id_list (ci_LP_SUBLIST_SOLID, list_entities, in_Mdl_SolidCount, FALSE, solid_Ids )

	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "fem_u_get_id_list when retrieving solid_Ids returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF		
	
	###################
	# Log Solid IDs
	###################		
	text_write_string( in_LogFile, "")   
	text_write_string( in_LogFile, "Solid IDs")   	
	
	FOR ( i = 1 TO in_Mdl_SolidCount BY 1 )
		text_write( in_LogFile, "   %I%",solid_Ids(i),0.0,"")
	END FOR	
	
	############################
	# Get Faces for Each Solid
	############################		

	FOR ( i = 1 TO in_Mdl_SolidCount BY 1 )
		out_Mdl_SolidIDs(i) = solid_Ids(i)
		sgm_db_get_num_faces_body(solid_Ids(i), num_faces, returnStatus)
		IF ( returnStatus != 0 ) THEN
			addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "sgm_db_get_num_faces_body returned an error, Return Status: " // str_from_integer(returnStatus)), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
			RETURN returnStatus			
		END IF
		
		out_Mdl_NumberSolidFaces(i) = num_faces
	
	END FOR		
	
    RETURN returnStatus	
	
END FUNCTION
#############################################################################################
# Currently this functon only works with faces on a solid (e.g. Solid 5.1).  Must extend for pure surfaces.
FUNCTION setSurfaceIDs( 										@
							in_Mdl_SolidCount,					@
							in_Mdl_SolidIDs, 					@
							in_Mdl_NumberSolidFaces,			@
							out_Mdl_NumberSurfaces, 	@
							out_Mdl_SurfaceIDs_internal,		@
							out_Mdl_SurfaceIDs_string,			@							
							in_LogFile, 						@
							in_ErrorMessages_maxCount,			@	
							in_out_ErrorMessages_current,		@									
							in_out_errorMessages )	
	INTEGER	in_Mdl_SolidCount
	INTEGER	in_Mdl_SolidIDs()		
	INTEGER in_Mdl_NumberSolidFaces()
	
	INTEGER out_Mdl_NumberSurfaces
	INTEGER	out_Mdl_SurfaceIDs_internal()	
	STRING	out_Mdl_SurfaceIDs_string[]()
	
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()		
	
	STRING functionName[64] = "setSurfaceIDs"	
	INTEGER	i
	INTEGER j
	INTEGER counter
	INTEGER returnStatus = 0	
	
	out_Mdl_NumberSurfaces = 0
	
	###########################
	# Count Number of Surfaces
	###########################
	FOR ( i = 1 TO in_Mdl_SolidCount BY 1 )
		out_Mdl_NumberSurfaces = out_Mdl_NumberSurfaces + in_Mdl_NumberSolidFaces(i)
	END FOR	
	
	#################################
	# Allocate Array for Surface IDs
	#################################	
	returnStatus = sys_allocate_array(out_Mdl_SurfaceIDs_internal, 1, out_Mdl_NumberSurfaces)
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "sys_allocate_array for allocating out_Mdl_SurfaceIDs_internal array returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF		


	returnStatus = sys_allocate_array(out_Mdl_SurfaceIDs_string, 1, out_Mdl_NumberSurfaces)
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "sys_allocate_array for allocating out_Mdl_SurfaceIDs_string array returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF			
	
	
	##################
	# Set Surface IDs
	##################	
  	
	INTEGER handle
	
	STRING surface_string[31]	
	INTEGER surf_intArray(1)	
	
	counter = 0
	
	#text_write_string(in_LogFile, "" )	
	#text_write_string(in_LogFile, "Solid Face    Internal Surface ID")	
	#text_write_string(in_LogFile, "-----------   --------------------")	
	FOR ( i = 1 TO in_Mdl_SolidCount BY 1 )
		FOR ( j = 1 TO in_Mdl_NumberSolidFaces(i) BY 1 )
			counter = counter + 1		
			
			surface_string = "Solid " // str_from_integer(in_Mdl_SolidIDs(i)) // "." // str_from_integer(j)
			
			returnStatus = lp_eval(surface_string, ci_LP_EVAL_FOR_ID , handle)	
			IF ( returnStatus != 0 ) THEN
				addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "lp_eval returned an error, Return Status: " // str_from_integer(returnStatus)), @
					in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
				RETURN returnStatus		
			END IF				
			
			returnStatus = lp_sublist_attribute_get_int(handle, ci_LP_ATTRIBUTE_ID, surf_intArray)	
			IF ( returnStatus != 0 ) THEN
				addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "lp_sublist_attribute_get_int returned an error, Return Status: " // str_from_integer(returnStatus)), @
					in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
				RETURN returnStatus		
			END IF	
			
			out_Mdl_SurfaceIDs_internal(counter) =  surf_intArray(1)
			out_Mdl_SurfaceIDs_string(counter) = surface_string
			lp_eval_cleanup(handle)
					
			#text_write_string( in_LogFile, surface_string // "     " // str_from_integer(out_Mdl_SurfaceIDs_internal(counter)))
			
		END FOR
	END FOR			
	
	RETURN returnStatus	
	
END FUNCTION	
#############################################################################################
FUNCTION logSurfaceIDs( in_Mdl_NumberSurfaces, 	@
						in_Mdl_SurfaceIDs_internal,			@
						in_Mdl_SurfaceIDs_string,			@						
						in_LogFile )
						
	INTEGER in_Mdl_NumberSurfaces
	INTEGER	in_Mdl_SurfaceIDs_internal()
	STRING	in_Mdl_SurfaceIDs_string[]()
	INTEGER in_LogFile		
	INTEGER	i		
			
	text_write_string(in_LogFile, "" )	
	text_write_string(in_LogFile, "Solid Face    Internal Surface ID")	
	text_write_string(in_LogFile, "-----------   --------------------")		
	
	FOR ( i = 1 TO in_Mdl_NumberSurfaces BY 1 )
		text_write_string( in_LogFile, in_Mdl_SurfaceIDs_string(i) // "     " // str_from_integer(in_Mdl_SurfaceIDs_internal(i)))
	END FOR
			
END FUNCTION	
#############################################################################################
FUNCTION pointsAreEqual( in_Point_1, in_Point_2, in_Tolerance )

	REAL	in_Point_1()
	REAL	in_Point_2()
	REAL	in_Tolerance

	If ( ABS(in_Point_1(1) - in_Point_2(1)) <  in_Tolerance &&  @
		 ABS(in_Point_1(2) - in_Point_2(2))  < in_Tolerance &&  @
		 ABS(in_Point_1(3) - in_Point_2(3))  < in_Tolerance ) THEN
		 return TRUE
	ELSE
		return FALSE
	END IF
	
END FUNCTION
#############################################################################################
FUNCTION determineIf_PointOnSurface( 	in_Point, 				@
							in_Mdl_SurfaceID_internal,			@
							out_PointOnSurface,					@							
							in_LogFile, 						@
							in_ErrorMessages_maxCount,			@	
							in_out_ErrorMessages_current,		@									
							in_out_errorMessages )	

	REAL	in_Point()
	Integer	in_Mdl_SurfaceID_internal
	LOGICAL out_PointOnSurface	
	INTEGER in_LogFile		
	INTEGER in_ErrorMessages_maxCount	
	INTEGER in_out_ErrorMessages_current	
	STRING 	in_out_errorMessages[]()
	
	STRING functionName[64] = "pointOnSurface"		
	
	INTEGER returnStatus = 0		
	
	REAL u
	REAL v
	INTEGER i_blob_size	
	REAL rv_surface(VIRTUAL)				
	##############################
	# Determine Surface Blob Size
	##############################
		
	# Getting the blob size for surface(entity type = 3) and allocating
	sgm_db_get_blob_size(3, in_Mdl_SurfaceID_internal, i_blob_size, returnStatus) 

	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "sgm_db_get_blob_size returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF		

	#########################
	# Allocate Surface Blob
	#########################	
	sys_allocate_array(rv_surface,1,i_blob_size)				
	
	#########################
	# Get Surface
	#########################
	INTEGER surf_IntArray(1)
	surf_IntArray(1) = in_Mdl_SurfaceID_internal
	
	sgm_db_get_surface(in_Mdl_SurfaceID_internal,i_blob_size,rv_surface, returnStatus)	

	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "sgm_db_get_surface returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF			

	################################
	# Get Nearest Point on Surface
	#################################
	REAL xyz_vectors_direction(4,3)		
	sgm_nearest_point_on_surface( in_Point, rv_surface, u, v, xyz_vectors_direction)
	
	# dump (in_Point)
	# dump (in_Mdl_SurfaceID_internal)
	# dump u
	# dump v
	# dump ( xyz_vectors_direction )
	
	################################
	# Free Meomory
	#################################	
	sys_free_array(rv_surface)
		
	REAL nearestPoint(3)
	nearestPoint(1) = 	xyz_vectors_direction(1,1)
	nearestPoint(2) = 	xyz_vectors_direction(1,2)
	nearestPoint(3) = 	xyz_vectors_direction(1,3)	
		
	out_PointOnSurface = PatranModel.pointsAreEqual( in_Point, nearestPoint, .005 )
		
	# dump out_PointOnSurface	
	RETURN returnStatus	
	
END FUNCTION
#############################################################################################
FUNCTION setPoints_to_SurfaceInternalIDs(	in_Point_Count, 					@
											in_Point_x,							@
											in_Point_y,							@
											in_Point_z,							@
											in_Mdl_NumberSurfaces,		@
											in_Mdl_SurfaceIDs_internal, 		@
											out_Point_SurfaceInPatranModel, 	@
											out_point_Mdl_SurfaceIDs_index, 	@
											in_LogFile, 						@
											in_ErrorMessages_maxCount,			@	
											in_out_ErrorMessages_current,		@									
											in_out_errorMessages )

	INTEGER		in_Point_Count
	REAL		in_Point_x()
	REAL		in_Point_y()
	REAL		in_Point_z()				
	INTEGER		in_Mdl_NumberSurfaces
	INTEGER		in_Mdl_SurfaceIDs_internal()			
	LOGICAL		out_Point_SurfaceInPatranModel()
	INTEGER		out_point_Mdl_SurfaceIDs_index()
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()	
	
	STRING functionName[64] = "setPoints_to_SurfaceInternalIDs"	
	INTEGER returnStatus = 0		
	INTEGER		i
	INTEGER		j
	
	LOGICAL pointOnSurface
	
	REAL point(3)
	
	FOR ( i = 1 TO in_Point_Count BY 1 )

		point(1) = in_Point_x(i)
		point(2) = in_Point_y(i)
		point(3) = in_Point_z(i)
		
		FOR ( j = 1 TO in_Mdl_NumberSurfaces BY 1 )		
		
			returnStatus = PatranModel.determineIf_PointOnSurface( 	@
								point,	@
								in_Mdl_SurfaceIDs_internal(j),	@
								pointOnSurface,					@							
								in_LogFile, 					@
								in_ErrorMessages_maxCount,		@	
								in_out_ErrorMessages_current,	@									
								in_out_errorMessages )	
								
			IF ( returnStatus != 0 ) THEN
				return returnStatus
			ELSE
				IF ( pointOnSurface ) THEN
					out_Point_SurfaceInPatranModel(i) = TRUE
					out_point_Mdl_SurfaceIDs_index(i) = j
					Break
				END IF
			END IF
		END FOR
	END FOR
	
	return returnStatus

END FUNCTION
#############################################################################################
FUNCTION logPoints_to_SurfaceInternalIDs(								@	
									in_Point_Count, 					@
									in_point_ID,						@
									in_Point_x,							@
									in_Point_y,							@
									in_Point_z,							@
									in_Point_SurfaceInPatranModel, 		@
									in_point_Mdl_SurfaceIDs_index, 		@
									in_mdl_SurfaceIDs_internal,			@
									in_mdl_SurfaceIDs_string,			@										
									in_LogFile ) 	
									
	INTEGER		in_Point_Count
	INTEGER 	in_point_ID()
	REAL		in_Point_x()
	REAL		in_Point_y()
	REAL		in_Point_z()					
	LOGICAL		in_Point_SurfaceInPatranModel()
	INTEGER		in_point_Mdl_SurfaceIDs_index()
	INTEGER		in_mdl_SurfaceIDs_internal()
	STRING		in_mdl_SurfaceIDs_string[]()
	INTEGER 	in_LogFile		
	
	INTEGER i
	
	text_write_string( in_LogFile, "")
	text_write_string( in_LogFile, "Point ID   Surface UI Name    Surface Internal IID   x     Y      Z")	
	text_write_string( in_LogFile, "--------   ---------------	  -------------------    ----  ----   ----")		
	
	FOR ( i = 1 to in_Point_Count by 1 ) 	
		IF ( in_Point_SurfaceInPatranModel(i) ) THEN
			text_write_string( in_LogFile, 	"   "  @
											// str_from_integer(in_point_ID(i)) // "          " @ 
											// in_mdl_SurfaceIDs_string(i)      // "               " @											
											// str_from_integer(in_mdl_SurfaceIDs_internal(in_point_Mdl_SurfaceIDs_index(i))) // "              " @
											// str_from_real(in_Point_x(i))     //  "    "  @
											// str_from_real(in_Point_y(i))     // "    "  @
											// str_from_real(in_Point_z(i)) )
		Else
			text_write_string( in_LogFile, 	"   "  @
											// str_from_integer(in_point_ID(i)) // "          " @ 
											//  "None            " @											
											//  "       None            " @
											// str_from_real(in_Point_x(i))     //  "    "  @
											// str_from_real(in_Point_y(i))     // "    "  @
											// str_from_real(in_Point_z(i)) )
		END IF
	END FOR
									
END FUNCTION		
#############################################################################################
# Note - It would be an error if a geometry of type FACE (i.e. surface) does not refer to a
# point that has an associated surface.  This would happen if the user incorrectly referenced
# points in the CAD model.
FUNCTION verify_Geometry_to_SurfaceIDs(									@
									in_Geometry_Count,					@
									in_Geometry_ID,						@
									in_Geometry_Type,					@
									in_Geometry_Point_ID,				@
									in_Point_Count, 					@
									in_Point_SurfaceInPatranModel, 		@
									in_LogFile, 						@
									in_ErrorMessages_maxCount,			@	
									in_out_ErrorMessages_current,		@									
									in_out_errorMessages ) 	
		
	INTEGER		in_Geometry_Count
	INTEGER		in_Geometry_ID()
	INTEGER     in_Geometry_Type()
	INTEGER		in_Geometry_Point_ID()	
	INTEGER		in_Point_Count					
	LOGICAL		in_Point_SurfaceInPatranModel()
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()	

	INTEGER returnStatus = 0		
	INTEGER i
			
	STRING functionName[64] = "verify_Geometry_to_SurfaceIDs"	

	FOR ( i = 1 to in_Geometry_Count )
		IF ( in_Geometry_Point_ID(i) > in_Point_Count ) THEN
			addErrorMessage( @
				formatErrorMessage( c_ERROR, functionName, "A geometry construct refers to a point that does not exist, Geometry_ID: "  @
				// str_from_integer(in_Geometry_ID(i)) // ", Point ID: " //  str_from_integer(in_Geometry_Point_ID(i))), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
			RETURN returnStatus		
		END IF
	
		IF ( in_Geometry_Type(i) == ci_GEOMETRY_TYPE_FACE ) THEN
			IF ( !in_Point_SurfaceInPatranModel(in_Geometry_Point_ID(i)) ) THEN
				addErrorMessage( @
					formatErrorMessage( c_ERROR, functionName, "A geometry FACE/SURFACE construct refers to a point that does not have an associated surface geometry, Geometry_ID: "  @
				// str_from_integer(in_Geometry_ID(i)) // ", Point ID: " //  str_from_integer(in_Geometry_Point_ID(i))), @
				in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 				
				returnStatus = -1
			END IF		
		END IF	
	END FOR
	RETURN returnStatus			
END FUNCTION
#############################################################################################
FUNCTION constraintString ( in_Constraint_State_set, 	@
							in_Constraint_State,		@
							in_Constraint_Val_set,		@
							in_Constraint_Val )
							
	LOGICAL		in_Constraint_State_set
	INTEGER		in_Constraint_State	
	LOGICAL		in_Constraint_Val_set
	REAL		in_Constraint_Val

	STRING 		tempString[31]
	
	tempString = ""
	
	if ( in_Constraint_State_set || in_Constraint_Val_set ) THEN
		IF ( in_Constraint_State_set ) THEN
			IF ( in_Constraint_State == ci_FIXED ) THEN
				tempString = "0.0"
			END IF
		ELSE
			tempString = str_from_real(in_Constraint_Val)	
		END IF
	END IF

	RETURN tempString
	
END FUNCTION	
#############################################################################################
FUNCTION applyConstraint_Displacement(	in_Disp_ID,							@		
										in_Mdl_SurfaceID_string,			@							
										in_x_Disp_State,					@  
										in_y_Disp_State,					@
										in_z_Disp_State,					@
										in_x_Rot_State,						@  
										in_y_Rot_State,						@
										in_z_Rot_State,						@
																			@
										in_x_Disp_State_set,				@  
										in_y_Disp_State_set,				@
										in_z_Disp_State_set,				@
										in_x_Rot_State_set,					@  
										in_y_Rot_State_set,					@
										in_z_Rot_State_set,					@						
																			@
										in_x_Disp_Val,						@
										in_y_Disp_Val,						@
										in_z_Disp_Val,						@
										in_x_Rot_Val,						@
										in_y_Rot_Val,						@
										in_z_Rot_Val,						@
																			@
										in_x_Disp_Val_set,					@
										in_y_Disp_Val_set,					@
										in_z_Disp_Val_set,					@
										in_x_Rot_Val_set,					@
										in_y_Rot_Val_set,					@
										in_z_Rot_Val_set,					@
										in_LogFile, 						@
										in_ErrorMessages_maxCount,			@	
										in_out_ErrorMessages_current,		@									
										in_out_errorMessages ) 	
				
	  INTEGER	in_Disp_ID		
	  STRING    in_Mdl_SurfaceID_string[]						
	  # PatranModel.Fixed_Free_toStr (x_Disp_State))				
	  INTEGER	in_x_Disp_State,						@  
				in_y_Disp_State,						@
				in_z_Disp_State,						@
				in_x_Rot_State,							@  
				in_y_Rot_State,							@
				in_z_Rot_State
						
	  LOGICAL	in_x_Disp_State_set,					@  
				in_y_Disp_State_set,					@
				in_z_Disp_State_set,					@
				in_x_Rot_State_set,						@  
				in_y_Rot_State_set,						@
				in_z_Rot_State_set						
						
	  REAL		in_x_Disp_Val,							@
				in_y_Disp_Val,							@
				in_z_Disp_Val,							@
				in_x_Rot_Val,							@
				in_y_Rot_Val,							@
				in_z_Rot_Val
						
	  LOGICAL	in_x_Disp_Val_set,						@
				in_y_Disp_Val_set,						@
				in_z_Disp_Val_set,						@
				in_x_Rot_Val_set,						@
				in_y_Rot_Val_set,						@
				in_z_Rot_Val_set										
				
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()				
				
	INTEGER returnStatus = 0			
	STRING functionName[64] = "applyConstraint_Displacement"		
	
	/**** From Session File	
	loadsbcs_create2( "Disp_Set_Name", "Displacement", "Nodal", "", "Static", [ @
	"Solid 1.2"], "Geometry", "Coord 0", "1.", ["< 0 0 0    >", "< 0 0 0    >",  @
	"<     >", "<     >"], ["", "", "", ""] )	

	loadsbcs_create2( "Constraint_Set", "Displacement", "Nodal", "", "Static", [ @
	"Solid 1.5"], "Geometry", "Coord 0", "1.", ["< ,,9     >", "< 1,,2    >",  @
	"<     >", "<     >"], ["", "", "", ""] )	
	******/
	#####################
	# Constraint Surface
	#####################
	# ap_list  e.g. "Solid 1.2"
	STRING ap_list[31](1)	
	ap_list(1) = in_Mdl_SurfaceID_string
	
	###################################
	# Translation/Rotation Constraints
	###################################	

	STRING disp_x_string[31]
	STRING disp_y_string[31]
	STRING disp_z_string[31]	
	STRING rot_x_string[31]
	STRING rot_y_string[31]
	STRING rot_z_string[31]
	
	disp_x_string = PatranModel.constraintString( in_x_Disp_State_set, in_x_Disp_State, in_x_Disp_Val_set, in_x_Disp_Val )
	disp_y_string = PatranModel.constraintString( in_y_Disp_State_set, in_y_Disp_State, in_y_Disp_Val_set, in_y_Disp_Val )
	disp_z_string = PatranModel.constraintString( in_z_Disp_State_set, in_z_Disp_State, in_z_Disp_Val_set, in_z_Disp_Val )
	
	rot_x_string = PatranModel.constraintString( in_x_rot_State_set, in_x_rot_State, in_x_rot_Val_set, in_x_rot_Val )
	rot_y_string = PatranModel.constraintString( in_y_rot_State_set, in_y_rot_State, in_y_rot_Val_set, in_y_rot_Val )
	rot_z_string = PatranModel.constraintString( in_z_rot_State_set, in_z_rot_State, in_z_rot_Val_set, in_z_rot_Val )	
	
	STRING static_data[100](4)	
	
	static_data(1) = "<" // disp_x_string // "," // disp_y_string // "," // disp_z_string // ">"
	static_data(2) = "<" // rot_x_string  // "," //  rot_y_string // "," // rot_z_string  //  ">"	
	
	static_data(3) = "<>"
	static_data(4) = "<>"
	
	#dump static_data(1)
	#dump static_data(2)
	
	INTEGER I
	
	#FOR ( i = 5 To 20 )
	#	static_data(i) = ""
	#END FOR
	
	returnStatus = loadsbcs_create2( "Constraint_Set", "Displacement", "Nodal", "", "Static", ap_list, @
	"Geometry", "Coord 0", "1.", static_data, ["", "", "", ""] )

	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "loadsbcs_create2 returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF		
	
#	loadsbcs_create2( "Constraint_Set", "Displacement", "Nodal", "", "Static", [ @
#	"Solid 1.5"], "Geometry", "Coord 0", "1.", ["< ,,9     >", "< 1,,2    >",  @
#	"<     >", "<     >"], ["", "", "", ""] )

	RETURN returnStatus

END FUNCTION
#############################################################################################
FUNCTION applyLoad_Pressure(	in_Load_Value_ID,					@
								in_Mdl_SurfaceID_string,			@	
								in_Load_value_Scalar,				@
								in_Load_Value_Scalar_Set,			@						
								in_LogFile, 						@
								in_ErrorMessages_maxCount,			@	
								in_out_ErrorMessages_current,		@									
								in_out_errorMessages ) 					

				
	INTEGER		in_Load_Value_ID
	STRING    	in_Mdl_SurfaceID_string[]	
	
	REAL		in_Load_value_Scalar
	LOGICAL	    in_Load_Value_Scalar_Set
				
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()				
				
	INTEGER returnStatus = 0			
	STRING functionName[64] = "applyLoad_Pressure"		
	
	##########################
	# Make Sure Scalar is Set
	##########################	
	
	IF ( !in_Load_Value_Scalar_Set) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "in_Load_value_Scalar == 0.0, this must be a non-zero value, in_Load_Value_ID: " // str_from_integer(in_Load_Value_ID)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN -1		
	END IF
	
	#################
	# Load Surface
	#################
	# ap_list  e.g. "Solid 1.2"
	STRING ap_list[31](1)	
	ap_list(1) = in_Mdl_SurfaceID_string
	
	STRING static_data[100](1)	
	
	IF ( in_Load_value_Scalar == 0.0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "loadsbcs_create2 returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus	
	
	END IF
	
	
	static_data(1) = str_from_real(in_Load_value_Scalar)

	
	/**** From Session File	
	loadsbcs_create2( "Load_Set", "Pressure", "Element Uniform", "3D", "Static", [ @
	"Solid 5.1"], "Geometry", "", "1.", [" 3203"], [""] )	
	******/	
	
	returnStatus = loadsbcs_create2( "Load_Set", "Pressure", "Element Uniform", "3D", "Static", ap_list, @
	"Geometry", "", "1.", static_data, [""] )		
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "loadsbcs_create2 returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF		
	
	RETURN returnStatus

END FUNCTION			
			
#############################################################################################
FUNCTION createSolidMesh( 	in_Sol_Element_Type,				@
							in_M_Max_Global_Length,				@
							in_M_Max_Curv_Delta_Div_Edge_Ln,	@
							in_M_Ratio_Min_Edge_To_Max_Edge,	@
							in_M_Match_Face_Proximity_Tol,		@
							in_LogFile, 						@
							in_ErrorMessages_maxCount,			@	
							in_out_ErrorMessages_current,		@									
							in_out_errorMessages ) 	

	INTEGER				in_Sol_Element_Type
							
	REAL				in_M_Max_Global_Length,				@
						in_M_Max_Curv_Delta_Div_Edge_Ln,	@
						in_M_Ratio_Min_Edge_To_Max_Edge,	@
						in_M_Match_Face_Proximity_Tol
							
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()								
							
	INTEGER returnStatus = 0			
	STRING functionName[64] = "createSolidMesh"		
						
	INTEGER fem_create_mesh_solid_num_nodes
	INTEGER fem_create_mesh_solid_num_elems
	STRING fem_create_mesh_s_nodes_created[VIRTUAL]
	STRING fem_create_mesh_s_elems_created[VIRTUAL]
	
		


	
	#Mesh_Parameters
	#	ID = 1
	#	Max_Global_Length = .1
	#	Max_Curv_Delta_Div_Edge_Len = .1
	#	Ratio_Min_Edge_To_Max_Edge =  .2
	#	Match_Face_Proximity_Tol = .05

				
	STRING sa_mesher_val[32](4)
	
	# Example for session file.
	# sa_mesher_val(1) = "21.0729"  // Max_Global_Length:    		21.0729 Global Edge Length, when auto calculated,   Max_Global_Length
	# sa_mesher_val(2) = "0.1111"  // Max_Curv_Delta_Div_Edge_Len:   0.1111 Maximum k/l  Should be between 0 and .25, but could be higher, Max_Curv_Delta_Div_Edge_Len
	# sa_mesher_val(3) = "0.2222"   // Ratio_Min_Edge_To_Max_Edge:    0.2222  Minimum Edge Length = Global Edge Length * Ratio_Min_Edge_To_Max_Edge
	# sa_mesher_val(4) = "0.0"    Not sure what this is 

	# Match_Face_Proximity_Tol: 0.0049999999, REAL r_FMF_prox_tol
	
	sa_mesher_val(1) = str_from_real( in_M_Max_Global_Length)
	sa_mesher_val(2) = str_from_real( in_M_Max_Curv_Delta_Div_Edge_Ln )
	sa_mesher_val(3) = str_from_real( in_M_Ratio_Min_Edge_To_Max_Edge )
	sa_mesher_val(4) =	"0.0"
	
	REAL r_FMF_prox_tol 

	r_FMF_prox_tol = in_M_Match_Face_Proximity_Tol
	

	
   IF ( in_Sol_Element_Type	!= ci_ELEMENT_TYPE_TETRA4 && in_Sol_Element_Type != ci_ELEMENT_TYPE_TETRA10 ) THEN
			addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "fem_create_mesh_sol_5 returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN -1
	END IF
   
	  
   
   # s_elem_topo Tet4 or Tet10 
  STRING s_elem_topo[32]   
   
   IF ( in_Sol_Element_Type	== ci_ELEMENT_TYPE_TETRA4 ) THEN
		s_elem_topo = "Tet4"
   ELSE
		s_elem_topo = "Tet10"
   END IF
      
	
	/************* From session file
	fem_create_mesh_sol_5( "Solid 1:#", "TetHybrid", "Tet4", 4, ["21.0729",  @
	"0.1111", "0.2222", "0.0"], 16464, 1, 0, 0, 1, 0.0049999999, "Solid 1:#", "#", @
	"#", "Coord 0", "Coord 0", fem_create_mesh_solid_num_nodes,  @
	fem_create_mesh_solid_num_elems, fem_create_mesh_s_nodes_created,  @
	fem_create_mesh_s_elems_created )
	**************/
				
	returnStatus = fem_create_mesh_sol_5( "Solid 1:#", "TetHybrid", s_elem_topo, 4, sa_mesher_val, @
	16464, 1, 0, 0, 1, r_FMF_prox_tol, "Solid 1:#", "#", "#",  @
	"Coord 0", "Coord 0", fem_create_mesh_solid_num_nodes,  @
	fem_create_mesh_solid_num_elems, fem_create_mesh_s_nodes_created,  @
	fem_create_mesh_s_elems_created )
	
	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "fem_create_mesh_sol_5 returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF		
	
	RETURN returnStatus
	
END FUNCTION		
#############################################################################################	
FUNCTION writeImageFile( 	in_Filename, 						@
							in_ViewOrientation, 				@
							in_LogFile, 						@
							in_ErrorMessages_maxCount,			@	
							in_out_ErrorMessages_current,		@									
							in_out_errorMessages )

	STRING  	in_Filename[]
	REAL 		in_ViewOrientation()
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()
	
	STRING functionName[64] = "writeImageFile"
	
	INTEGER returnStatus = 0
	
	ga_view_aa_set( in_ViewOrientation(1), in_ViewOrientation(2), in_ViewOrientation(3) )
	gu_fit_view(  )
	mesh_seed_display_mgr.refresh(  )
	
	returnStatus = gm_write_image( "JPEG", in_Filename, "Overwrite", 0., 0., 1., 1., 75, "Viewport" )
	
	# 1 seems to be a legitimate return code from gm_write_image
	IF ( returnStatus != 0 &&  returnStatus != 1 ) THEN	
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "Could not create file.  File Name: " // in_Filename), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 		
		RETURN returnStatus
	END IF	

	text_write( in_LogFile, "    Image File: %A%",0,0.0, in_Filename)	
	
	RETURN 0 
	
END FUNCTION
#############################################################################################

FUNCTION WriteMeshImagesAndVRML( 	in_LogFile, 						@
									in_ErrorMessages_maxCount,			@	
									in_out_ErrorMessages_current,		@									
									in_out_errorMessages )

	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()
	
	REAL viewOrientation(3)
	
	INTEGER returnStatus_temp = 0
	INTEGER returnStatus = 0	
	
	STRING functionName[64] = "WriteMeshImagesAndVRML"
	
	STRING fileName[64]

	text_write_string ( in_LogFile, "" )			
	text_write_string ( in_LogFile, "Created Image Files:" )	
	
	# Front View
	fileName = "PatranMesh_front.jpg"
	viewOrientation(1) = 0.0
	viewOrientation(2) = 0.0
	viewOrientation(3) = 0.0	
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )	
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF
	
	# Top View
	fileName = "PatranMesh_top.jpg"	
	viewOrientation(1) = 90.0
	viewOrientation(2) = 0.0
	viewOrientation(3) = 0.0	
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )		
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF	
	
	
	# Right View
	fileName = "PatranMesh_right.jpg"
	viewOrientation(1) = 180.0
	viewOrientation(2) = -90.0
	viewOrientation(3) = 180.0	
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )		
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF	
	
	# ISO 1
	fileName = "PatranMesh_iso_1.jpg"	
	viewOrientation(1) = 23.0
	viewOrientation(2) = -34.0
	viewOrientation(3) = 0.0	
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )			
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF

	# ISO 2
	fileName = "PatranMesh_iso_2.jpg"	
	viewOrientation(1) = 23.0
	viewOrientation(2) = 56.0
	viewOrientation(3) = 0.0	
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )		
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF
	
	# ISO 3
	fileName = "PatranMesh_iso_3.jpg"	
	viewOrientation(1) = -67.0
	viewOrientation(2) = 0.0
	viewOrientation(3) = -34.0
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )			
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF	

	# ISO 4
	fileName = "PatranMesh_iso_4.jpg"	
	viewOrientation(1) = 157.0
	viewOrientation(2) = 34.0
	viewOrientation(3) = -180.0
	returnStatus_temp = PatranModel.writeImageFile( fileName, viewOrientation, 			@
													in_LogFile, 						@
													in_ErrorMessages_maxCount,			@	
													in_out_ErrorMessages_current,		@									
													in_out_errorMessages )	
	IF ( returnStatus_temp != 0 ) THEN
		returnStatus = returnStatus_temp
	END IF		
	
	# VMRL, Fix this later
	#fileName = "PatranMesh.wrl"	
	#IF ( returnStatus == 0 ) THEN returnStatus = gm_write_vrml(fileName,"Overwrite")

	#IF ( returnStatus != 0 &&  returnStatus != 1 ) THEN
	#	out_ErrorString = "Function: " // functionName // ", ERROR - Could not create file.  File Name: " // fileName	
	#	RETURN returnStatus
	#END IF	
	
	text_write( in_LogFile, "    VRML File:  %A%",0,0.0, fileName)
		
	RETURN returnStatus
	
END FUNCTION

#############################################################################################	
FUNCTION submitSolution101(	in_JobName,							@
							in_LogFile, 						@
							in_ErrorMessages_maxCount,			@	
							in_out_ErrorMessages_current,		@									
							in_out_errorMessages ) 
							
	STRING		in_JobName[]
	INTEGER 	in_LogFile		
	INTEGER 	in_ErrorMessages_maxCount	
	INTEGER 	in_out_ErrorMessages_current	
	STRING 		in_out_errorMessages[]()								
							
	INTEGER returnStatus = 0			
	STRING functionName[64] = "submitSolution101"								

	jobfile.open( in_JobName, "ANALYZE NO JOBFILE" )
	msc_delete_old_files( in_JobName, ".bdf", ".op2" )
	jobfile.write_spl( "/* Jobfile for PATNAS created %A% at %A% */", ["06-May-16" @
	, "14:32:06"] )
	jobfile.writec( "", "TRANSLATOR = pat3nas" )
	jobfile.writec( "DATABASE", "C:\Users\rowens\My_SVN\META_Sandbox\Blade_Win" // @
	"d_Turbine\PatranModels\PCL_Programs\SpecificFunctionalityExamples\01_Star" // @
	"t_PCL_DB\suppo" )
	jobfile.writec( "JOBNAME", in_JobName )
	jobfile.writec( "ANALYSIS TITLE", "MSC.Nastran job created on 06-May-16 at" // @
	" 14:30:53" )
	jobfile.writec( "ANALYSIS SUBTITLE", "" )
	jobfile.writec( "ANALYSIS LABEL", "" )
	jobfile.writec( "", "" )
	jobfile.writec( "OBJECT", "Entire Model" )
	jobfile.writec( "METHOD", "Full Run" )
	jobfile.writec( "", "" )
	jobfile.writec( "MODEL SUFFIX", ".bdf" )
	jobfile.writec( "RESULTS SUFFIX", ".op2" )
	jobfile.writec( "", "" )
	jobfile.writec( "", "/*" )
	jobfile.writec( "", " * File Search Path Declaration" )
	jobfile.writec( "", " */" )
	jobfile.writec( "", "" )
	jobfile.writec( "File Search Path", "C:\Users\rowens" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\help" // @
	"files" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\alters" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\icons" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\icon" // @
	"s\RibbonIcons" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\bin" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\bin\exe" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\msce" // @
	"xplore_files\" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\mscp" // @
	"rocor_files\dmap" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\mscp" // @
	"rocor_files\plb" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\mscp" // @
	"rocor_files\lib" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\mscp" // @
	"rocor_files\icons" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\shar" // @
	"eware\msc\unsupported\utilities\icons" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\shar" // @
	"eware\msc\unsupported\utilities\plb" )
	jobfile.writec( "File Search Path", "C:\MSC.Software\Patran_x64\20140\shar" // @
	"eware\msc\unsupported\utilities\extra_files" )
	jobfile.writec( "", "" )
	jobfile.writec( "", "/*" )
	jobfile.writec( "", " * Translation Parameters" )
	jobfile.writec( "", " */" )
	jobfile.writec( "", "" )
	jobfile.writec( "DATA OUTPUT", "XDB+PRINT" )
	jobfile.writec( "OUTPUT2 REQUESTS", "P3 Built In" )
	jobfile.writec( "OUTPUT2 FORMAT", "Binary" )
	jobfile.writec( "DIVISION TOLERANCE", "1.0e-08" )
	jobfile.writec( "NUMERICAL TOLERANCE", "1.0e-04" )
	jobfile.writec( "WRITING TOLERANCE", "1.0e-21" )
	jobfile.writec( "GEOM CHECK", "INFORM" )
	jobfile.writec( "SORTED BULK", "NO" )
	jobfile.writec( "CARD FORMAT", "either" )
	jobfile.writec( "NODE COORDINATES", "reference frame" )
	jobfile.writec( "COORD COORDINATES", "global" )
	jobfile.writec( "MSC.Nastran VERSION", "2014." )
	jobfile.writec( "WRITE STORED PRECISION", "TRUE" )
	jobfile.writec( "PROPS ON ELEM ENTRY", "FALSE" )
	jobfile.writec( "CONTINUATION ENTRY", "FALSE" )
	jobfile.writec( "PCOMPG ENTRY", "TRUE" )
	jobfile.writec( "CONVERT CBAR CBEAM", "FALSE" )
	jobfile.writec( "ITERATIVE SOLVER", "FALSE" )
	jobfile.writei( "SUPER ELEMENT 0", 0 )
	jobfile.writec( "SEALL WRITE", "FALSE" )
	jobfile.writec( "PART SUPERELEMENT CREATE", "TRUE" )
	jobfile.writec( "AUTOQSET", "FALSE" )
	jobfile.writec( "FIXEDB", "FALSE" )
	jobfile.writei( "SUPER TREE COUNT", 0 )
	jobfile.writec( "MODEL TOLERANCE", "0.0049999999" )
	jobfile.writec( "ELEMENT PROPERTY OFFSET", "0" )
	jobfile.writec( "MATERIAL PROPERTY OFFSET", "0" )
	jobfile.writec( "TABLE OFFSET", "0" )
	jobfile.writec( "LOAD SET OFFSET", "0" )
	jobfile.writec( "LOAD CASE OFFSET", "0" )
	jobfile.writec( "CONTROL SET OFFSET", "0" )
	jobfile.writec( "RIGID ELEMENT OFFSET", "0" )
	jobfile.writec( "SCALAR POINT OFFSET", "0" )
	jobfile.writec( "BEGINNING CONTINUATION MARKER", "+      A" )
	jobfile.writec( "NUMBER ONLY", "ON" )
	jobfile.writec( "BEGINNING NUMBER", "OFF" )
	jobfile.writec( "TRAILING NUMBER", "OFF" )
	jobfile.writec( "SYNTAX NUMBER", "ON" )
	jobfile.writec( "SYNTAX MARKER", "." )
	jobfile.writec( "EXTERNAL SUPERELEMENT METHOD", "NONE" )
	jobfile.writec( "GRID COORDINATES ROUNDING", "15" )
	jobfile.writec( "COORD DATA PRECISION ROUNDING", "15" )
	jobfile.writec( "MPC DATA PRECISION ROUNDING", "15" )
	jobfile.writec( "LBC DATA PRECISION ROUNDING", "7" )
	jobfile.writec( "MAT DATA PRECISION ROUNDING", "7" )
	jobfile.writec( "PROP DATA PRECISION ROUNDING", "7" )
	jobfile.writec( "", "" )
	jobfile.writec( "", "/*" )
	jobfile.writec( "", " * Solution Parameters" )
	jobfile.writec( "", " */" )
	jobfile.writec( "", "" )
	jobfile.writec( "SOLUTION TYPE", "LINEAR STATIC" )
	jobfile.writei( "SOLUTION SEQUENCE", 101 )
	jobfile.writec( "DATABASE RUN", "ON" )
	jobfile.writec( "CYCLIC SYMMETRY", "OFF" )
	jobfile.writec( "AUTOMATIC CONSTRAINTS", "ON" )
	jobfile.writec( "INERTIA RELIEF", "OFF" )
	jobfile.writec( "ALTERNATE REDUCTION", "OFF" )
	jobfile.writec( "SHELL NORMAL TOLERANCE", "" )
	jobfile.writec( "MASS CALCULATION", "Lumped" )
	jobfile.writec( "DATA DECK ECHO", "None" )
	jobfile.writec( "PLATE RZ STIFFNESS FACTOR", "100.0" )
	jobfile.writec( "MAXIMUM PRINTED LINES", "" )
	jobfile.writec( "MAXIMUM RUN TIME", "" )
	jobfile.writec( "WT-MASS CONVERSION", "1.0" )
	jobfile.writec( "NODE ID FOR WT-GENER", "" )
	jobfile.writec( "RIGID ELEMENT TYPE", "LINEAR" )
	jobfile.writec( "USE SOL600", "OFF" )
	jobfile.writei( "CONTACT-SEGMENT-CONTROL METHOD", 0 )
	jobfile.writei( "CONTACT-DEFORMABLE-DEFORMABLE METHOD", 0 )
	jobfile.writei( "CONTACT-CRITERION", 0 )
	jobfile.writei( "CONTACT-DERIVATION", 0 )
	jobfile.writei( "CONTACT-REL_ABS", 0 )
	jobfile.writec( "USE SOL700", "OFF" )
	jobfile.writec( "SN MEAN STRESS CORRECTION", "NONE" )
	jobfile.writec( "NEF STRESS UNITS", "MPA" )
	jobfile.writec( "NEF STRESS COMBINATION", "ABSMAXPR" )
	jobfile.writec( "NEF RESULT LOCATION", "NODE" )
	jobfile.writec( "NEF INTERPOLATION LIMIT", "0" )
	jobfile.writec( "NEF LEVEL OF MESSAGE", "0" )
	jobfile.writec( "NEF NUMBER OF THREADS", "1" )
	jobfile.writer( "NEF CERTAINTY OF SURVIVAL", 50. )
	jobfile.writer( "NEF OVERALL SCALE FACTOR", 1. )
	jobfile.writer( "NEF TOP STRESS PERCENTAGE FILTER", 100. )
	jobfile.writer( "NEF TOP DAMAGE PERCENTAGE FILTER", 100. )
	jobfile.writec( "NEF TIME HISTORY DIRECTORY", "C:\Users\rowens" )
	jobfile.writei( "NEF MAX LOAD PER EVENT", 1 )
	jobfile.writec( "NEF EVENT DATA", "0" )
	jobfile.writec( "NEF LOAD SEQUENCE DATA", "0" )
	jobfile.writec( "USE CONTACT TABLE", "OFF" )
	jobfile.writec( "INITIAL CONTACTPAIR LOADCASE NAME", "" )
	jobfile.writei( "MDOF DATA", 0 )
	jobfile.writec( "CELL WRITE", "ON" )
	jobfile.writei( "CELL INPUT 0", 0 )
	jobfile.writec( "FMS WRITE", "ON" )
	jobfile.writei( "FMS INPUT 0", 0 )
	jobfile.writec( "EXEC WRITE", "ON" )
	jobfile.writei( "EXEC INPUT 0", 0 )
	jobfile.writec( "CASE WRITE", "ON" )
	jobfile.writei( "CASE INPUT 0", 0 )
	jobfile.writec( "BULK WRITE", "ON" )
	jobfile.writei( "BULK INPUT 0", 0 )
	jobfile.writec( "CELL DTI POSITION", "START" )
	jobfile.writec( "FMS DTI POSITION", "START" )
	jobfile.writec( "EXEC DTI POSITION", "START" )
	jobfile.writec( "CASE DTI POSITION", "START" )
	jobfile.writec( "BULK DTI POSITION", "START" )
	jobfile.writec( "", "END" )
	jobfile.close(  )
	returnStatus = mscnastran_job.associate_subcases( "101", in_JobName, 1, ["Default"] )	

	IF ( returnStatus != 0 ) THEN
		addErrorMessage( @
			formatErrorMessage( c_ERROR, functionName, "mscnastran_job.associate_subcases returned an error, Return Status: " // str_from_integer(returnStatus)), @
			in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
        RETURN returnStatus		
	END IF			
	
	analysis_submit_2( "MSC.Nastran", in_JobName )
	# analysis_submit_2 does not return a returnStatus
	#IF ( returnStatus != 0 ) THEN
	#	addErrorMessage( @
	#		formatErrorMessage( c_ERROR, functionName, " analysis_submit_2c returned an error, Return Status: " // str_from_integer(returnStatus)), @
	#		in_ErrorMessages_maxCount, in_out_ErrorMessages_current, in_out_errorMessages) 
    #   RETURN returnStatus		
	#END IF		
	
	
	RETURN returnStatus
	
END FUNCTION	
#############################################################################################
	
END CLASS
